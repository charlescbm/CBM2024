#Include "RWMAKE.CH"
#Include "Protheus.ch"                        
#Include "ap5mail.ch"

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммкмммммммяммммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Programa  ЁCERT2     ╨Autor  ЁMicrosiga           ╨ Data Ё  02/06/06   ╨╠╠
╠╠лммммммммммьммммммммммймммммммоммммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Desc.     ЁImpressao de Certificados de Qualidade                      ╨╠╠
╠╠╨          Ё                                                            ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё Brascola                                                   ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨ParametrosЁ BR_EMCERT - E-mail que sera notificado das inconsistencias ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Rogerio   Ё Implementacao de melhorias na rotina                       ╨╠╠
╠╠╨06/02/06  Ё - Permitir impressao de Certificados diretamente do modulo ╨╠╠
╠╠╨          Ёde inspecao de entregas                                     ╨╠╠
╠╠╨          Ё - Permitir impressao de itens de segundo nivel na estrutura╨╠╠
╠╠╨          Ёquando nao encontrar no primeiro nivel                      ╨╠╠
╠╠╨          Ё - Imprimir relatorio final com inconsistencias em vez de   ╨╠╠
╠╠╨          Ёcertificados parciais inconsistentes.                       ╨╠╠
╠╠╨Elias ReisЁ - Permitir impressao de certificados de itens da NF, para o╨╠╠
╠╠╨30/08/06  Ё   caso de o usuario ja ter impresso o certificado de algum ╨╠╠
╠╠╨          Ё   item, e nao ter que repetir a impressao de todos novament╨╠╠
╠╠╨          Ё   e.                                                       ╨╠╠
╠╠хммммммммммомммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/

USER FUNCTION CERTQUA2()

Local aRegs         := {}
Local cOP           := ""
Local cChave        := ""
Local cPerg         := "CTFQLD"                 					
Local _aCBC         := {}
Local _aItem 		:= {}
Local _aResul		:= {}
Local lGravaCBC	    := .f.
Local aInconSub1 	:= {}
Local aInconSub2 	:= {}
Local aEstrutura	:= {}
Local nCasas
Private cProduto    := ""
Private aIncon      := {}
Private cLote       := ""

// здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
// Ё Prepara perguntas de filtro para emissao do(s) Certificado(s)  Ё
// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
AADD(aRegs,{cPerg,"01","NF Inicial         ?"," "," ","mv_ch1","C",09,0,0,"G","","mv_par01"})
AADD(aRegs,{cPerg,"02","NF Final           ?"," "," ","mv_ch2","C",09,0,0,"G","","mv_par02"})
AADD(aRegs,{cPerg,"03","Serie              ?"," "," ","mv_ch3","C",03,0,0,"G","","mv_par03"})
AADD(aRegs,{cPerg,"04","Produto        	   ?"," "," ","mv_ch4","C",15,0,0,"G","","mv_par04"})
//AADD(aRegs,{ALLTRIM(cPerg),"05","Item Final         ?"," "," ","mv_ch5","C",2,0,0,"G","","mv_par05"})

// здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
// Ё Cria as perguntas, caso nao as encontre no SX1                 Ё
// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
//dbSelectArea("SX1")
//For i:=1 to Len(aRegs)
//	If !dbSeek(cPerg+aRegs[i,2])
//		RecLock("SX1",.T.)
//		For j:=1 to FCount()
//			FieldPut(j,aRegs[i,j])
//		Next
//		MsUnlock()
//		dbCommit()
//	Endif
//Next

Pergunte(cPerg,.f.)
lValidPerg(aRegs)

// здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
// Ё Cria arquivo temporario com cabecalho do certificado (CBC)     Ё
// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды

Aadd(_aCBC,{"NOTA"         ,"C",009,0})
Aadd(_aCBC,{"SERIE"        ,"C",003,0})
Aadd(_aCBC,{"CLIENTE"      ,"C",008,0})
Aadd(_aCBC,{"LOJA"         ,"C",004,0})
Aadd(_aCBC,{"PRODUTO"      ,"C",015,0})
Aadd(_aCBC,{"ITEM"         ,"C",004,0})
Aadd(_aCBC,{"NOME"         ,"C",040,0})
Aadd(_aCBC,{"EMISSAO"      ,"D",008,0})

_cArqCbc := CriaTrab(_aCBC,.T.)

//Verifica se o Alias jА estА aberto, antes de abrir novamente
//Elias 08/02/2006
If Select("CBC") > 0
	dbCloseArea("CBC")
EndIF

dbUseArea( .T.,,_cArqCbc, "CBC", .F., .F. )

// зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
// Ё Cria arquivo temporario com itens do certificado (ITEM)     Ё
// юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
Aadd(_aItem,{"NOTA"         ,"C",009,0})
Aadd(_aItem,{"SERIE"        ,"C",003,0})
Aadd(_aItem,{"PRODUTO"      ,"C",015,0})
Aadd(_aItem,{"ITEM"         ,"C",004,0})
Aadd(_aItem,{"DESC"         ,"C",050,0})
Aadd(_aItem,{"UM"           ,"C",002,0})
Aadd(_aItem,{"LOTE"         ,"C",011,0})
Aadd(_aItem,{"FABRI"        ,"D",008,0})
Aadd(_aItem,{"DTVALID"      ,"D",008,0})
Aadd(_aItem,{"QUANT"        ,"N",014,2})

_cArqItm := CriaTrab(_aItem,.T.)

If Select("ITEM") > 0
	dbCloseArea("ITEM")
EndIF
dbUseArea( .T.,,_cArqItm, "ITEM", .F., .F. )

// здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
// Ё Cria arquivo temporario com detalhes do certificado por item (RESUL) Ё
// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
Aadd(_aResul,{"NOTA"         ,"C",009,0})
Aadd(_aResul,{"SERIE"        ,"C",003,0})
Aadd(_aResul,{"PRODUTO"      ,"C",015,0})
Aadd(_aResul,{"ITEM"         ,"C",004,0})
Aadd(_aResul,{"LOTE"         ,"C",011,0})
Aadd(_aResul,{"ENSAIO"       ,"C",050,0})
Aadd(_aResul,{"NOME"         ,"C",050,0})
Aadd(_aResul,{"ESPEC"        ,"C",050,0})
Aadd(_aResul,{"RESULT"       ,"C",050,0})

_cArqRes := CriaTrab(_aResul,.T.)

If Select("RESUL") > 0
	dbCloseArea("RESUL")
EndIF

dbUseArea(.T.,,_cArqRes,"RESUL",.F.,.F.)

//ProcRegua(VAL(MV_PAR02) - VAL(MV_PAR02))
ProcRegua(VAL(MV_PAR02) - VAL(MV_PAR01))

IF PERGUNTE(cPerg)
	PERGUNTE(cPerg,.F.)
	
	CursorWait()
	
	// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	// Ё Varre Notas Fiscais de Saida com o Filtro Selecionado  Ё
	// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	DbSelectArea("SF2")
	SF2->(DbSetOrder(1))
	//	IF DBSEEK( XFILIAL("SF2") + MV_PAR01 + MV_PAR03 )
	DBSEEK( XFILIAL("SF2") + MV_PAR01 + MV_PAR03 )
	
	While SF2->(!EOF()) .AND. AllTrim(SF2->F2_FILIAL) == xFilial("SF2") .AND. AllTrim(SF2->F2_DOC) <= AllTrim(MV_PAR02) .AND. AllTrim(SF2->F2_SERIE) <= AllTrim(MV_PAR03)	
		If AllTrim(SF2->F2_SERIE) <> AllTrim(MV_PAR03)
		   SF2->(DBSKIP())
		   LOOP
		ENDIF
		   	
		// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		// Ё So trata Cliente / Desconsidera Fornecedor             Ё
		// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If SF2->F2_TIPO $ "BD"
			DBSELECTAREA("SF2")
			SF2->(DbSkip())
			Loop
		Endif
		
		cOP := ""
		INCPROC("Selecionando Registros")
		DBSELECTAREA("SA1")
		DBSETORDER(1)
		If SA1->(DBSEEK( xFilial("SA1") + SF2->F2_CLIENTE + SF2->F2_LOJA ))
			// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			// Ё Valida se cliente necessita de certificado             Ё
			// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If SA1->A1_CERTQUA $ "1/S"
				DBSELECTAREA("SD2")
				DBSETORDER(3)
				
				// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				// Ё Varre os itens da Nota Fiscal                          Ё
				// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				IF DBSEEK( XFILIAL("SD2") + SF2->F2_DOC + SF2->F2_SERIE)
					WHILE !EOF() .AND. ALLTRIM(SD2->D2_DOC) == ALLTRIM(SF2->F2_DOC) .AND. ALLTRIM(SD2->D2_SERIE) == ALLTRIM(SF2->F2_SERIE)
						
						// здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						// Ё Desconsiderar itens que estiverem fora do range selecionadoЁ
						// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						//If SD2->D2_ITEM < mv_par04 .Or. SD2->D2_ITEM > mv_par05
						If !Empty(AllTrim(mv_par04)) .And. !SD2->D2_COD == mv_par04
							SD2->(DbSkip())
							Loop
						Endif
											
						// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						// Ё Desconsiderar vendas sem numero de lote                Ё
						// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						If Empty(SD2->D2_LOTECTL)
							SD2->(DbSkip())
							Loop
						Endif
						
						cOP		:= ""
						cProduto := ""
						
						// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						// Ё Analise de quais dados serao impressos no certificado  Ё
						// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						
						// здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						// Ё 1. Verifica se existe Especificacao, OP e Resultado Deste Lote   Ё
						// Ё no Modulo de Inspecao de Processos                               Ё
						// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						
						DbSelectArea("QP6")
						QP6->(DbSetOrder(1))
						If QP6->(DbSeek( xFilial("QP6") + SD2->D2_COD)) .AND. QP6->QP6_SKPLOT <> '27'
							cProduto := ALLTRIM(SD2->D2_COD)
							
							DbSelectArea("SC2")
							SC2->(DbSetOrder(10))		// C2_FILIAL+C2_LOTECTL+C2_PRODUTO
							//IF DBSEEK( "01" + SD2->D2_LOTECTL + cProduto) // Daniel Neves - 19.09.05 - Indice sem produto
							If SC2->(DbSeek(xFilial("SC2")+SD2->D2_LOTECTL))
								While SC2->(!EOF()) .AND. SC2->C2_LOTECTL == SD2->D2_LOTECTL  									
									IF AllTrim(SC2->C2_PRODUTO ) == cProduto
										//cOP := SC2->C2_NUM + SC2->C2_ITEM + SC2->C2_SEQUEN
										cOP := AllTrim(SC2->C2_NUM) + AllTrim(SC2->C2_ITEM) + AllTrim(SC2->C2_SEQUEN) //- Daniel N. - os registros tem que ser identicos
										Exit
									ENDIF
									SC2->(DbSkip())
								ENDDO
								
								DbSelectArea("QPR")//MediГУes √ Dados GenИricos
								QPR->(DbSetOrder(8)) 	// QPR_FILIAL+QPR_OP+QPR_LOTE+QPR_OPERAC+QPR_LABOR+QPR_ENSAIO+DTOS(QPR_DTMEDI)+QPR_HRMEDI+STR(QPR_AMOSTR,1)
								If QPR->(DbSeek( xFilial("QPR") + cOP + "  " + SD2->D2_LOTECTL ))
									If GravaCBC("QIP")
										GravaQIP(cOP,SD2->D2_LOTECTL)
									Endif
								Else
									Aadd(aIncon,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto,cOP,"OP " + cOP + " do Lote " + SD2->D2_LOTECTL + " sem resultados"})
									// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
									// Ё Inicia analise do proximo item da Nota Fiscal de Saida Ё
									// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
									DbSelectArea("SD2")
									SD2->(DbSkip())
									Loop
								Endif
								
								// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								// Ё Inicia analise do proximo item da Nota Fiscal de Saida Ё
								// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
								DbSelectArea("SD2")
								SD2->(DbSkip())
								Loop
								
								// здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								// Ё Bloco abaixo comentado em 28/04 - Pois encontramos um produto no QIP e QIE Ё
								// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
								/*
								Else
								
								Aadd(aIncon,{SD2->D2_DOC + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto," ","Lote " + SD2->D2_LOTECTL + " do produto " + cProduto + " sem OP"})
								// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								// Ё Inicia analise do proximo item da Nota Fiscal de Saida Ё
								// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
								DbSelectArea("SD2")
								SD2->(DbSkip())
								Loop
								*/
							Endif
						Endif
						
						// зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						// Ё 3. Analisa estrutura do produto e imprime valores dos resultados de   Ё
						// Ё todos os PIs da estrutura                                             Ё
						// юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						DbSelectArea("SG1")
						SG1->(DbSetOrder(1))
						QP6->(DbSetOrder(1))
						
						aInconSub1 	:= {}
						aInconSub2 	:= {}
						aEstrutura	:= {}
						
						If SG1->(DbSeek(xFilial("SG1") + SD2->D2_COD))
							lGravaCBC := .f.
							While SG1->(!EOF()) .AND. ;
								AllTrim(SG1->G1_COD) == AllTrim(SD2->D2_COD)
								
								// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								// Ё Considerar somente PI/PAs				                  Ё
								// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
								If ! AllTrim(Posicione("SB1",1,xFilial("SB1")+SG1->G1_COD,"B1_TIPO")) $ "3/4"
									SG1->(DbSkip())
									Loop
								Endif
								
								// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								// Ё Carrega com a estrutura a ser avaliada no nivel 2      Ё
								// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
								Aadd(aEstrutura,SG1->G1_COMP)
								If QP6->(DbSeek(xFilial("QP6") + SG1->G1_COMP))
									cProduto := ALLTRIM(SG1->G1_COMP)
									
									// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
									// Ё O Lote do PA eh igual ao Lote do PI                    Ё
									// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
									DbSelectArea("SC2")
									SC2->(DbSetOrder(10))		// C2_FILIAL+C2_LOTECTL+C2_PRODUTO
									lNumeroPAPI := .T.
									cOp := ""
									If SC2->(DbSeek(xFilial("SC2") + SD2->D2_LOTECTL))
										While SC2->(!EOF()) .AND. ;
											SC2->C2_LOTECTL == SD2->D2_LOTECTL
											IF AllTrim(SC2->C2_PRODUTO ) == cProduto
												cOP := AllTrim(SC2->C2_NUM) + AllTrim(SC2->C2_ITEM) + AllTrim(SC2->C2_SEQUEN) //- Daniel N. - os registros tem que ser identicos
												Exit
											Endif
											SC2->(DbSkip())
										Enddo		
										If Empty(cOP)
											lNumeroPAPI := .f.
										Else
										//	Aadd(aInconSub1,{SD2->D2_DOC + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto," ","Lote " + SD2->D2_LOTECTL + " sem OP para o produto " + cProduto + " da estrutura"})
										//	SG1->(DbSkip())
										//	Loop

											DbSelectArea("QPR")
											QPR->(DbSetOrder(8)) 	// QPR_FILIAL+QPR_OP+QPR_LOTE+QPR_OPERAC+QPR_LABOR+QPR_ENSAIO+DTOS(QPR_DTMEDI)+QPR_HRMEDI+STR(QPR_AMOSTR,1)
											If QPR->(DbSeek( xFilial("QPR") + cOP + "  " + SD2->D2_LOTECTL ))
												GravaQIP(cOP,SD2->D2_LOTECTL)
												lGravaCBC := .t.
											Else
												Aadd(aInconSub1,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto,cOP,"OP " + cOP + " do Lote " + SD2->D2_LOTECTL + " sem resultados"})
												
												// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
												// Ё Inicia analise do proximo item da estrutura            Ё
												// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
												SG1->(DbSkip())
												Loop
											Endif	
										Endif	
									Endif
									
									// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
									// Ё Nao encontrou OP de PI com o mesmo numero da OP do PA  Ё
									// Ё Ira analisar os lotes utilizados na OP para localizar  Ё
									// Ё qual lote de PI foi utilizado na fabricacao do PA e    Ё
									// Ё imprime os dados deste lote.                           Ё
									// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
									If ! lNumeroPaPi
										SC2->(DbSetOrder(10))		// C2_FILIAL+C2_LOTECTL+C2_PRODUTO
										If SC2->(DbSeek(xFilial("SC2") + SD2->D2_LOTECTL + SD2->D2_COD))
											SD3->(DbSetOrder(1))		//	D3_FILIAL+D3_OP+D3_COD+D3_LOCAL
											If SD3->(DbSeek(xFilial("SD3") + SC2->(C2_NUM + C2_ITEM + C2_SEQUEN + C2_ITEMGRD) + cProduto))
												If ! Empty(SD3->D3_LOTECTL)
													If SC2->(DbSeek(xFilial("SC2") + SD3->D3_LOTECTL + cProduto))
														cOp := SC2->(C2_NUM + C2_ITEM + C2_SEQUEN)
														DbSelectArea("QPR")
														QPR->(DbSetOrder(8)) 	// QPR_FILIAL+QPR_OP+QPR_LOTE+QPR_OPERAC+QPR_LABOR+QPR_ENSAIO+DTOS(QPR_DTMEDI)+QPR_HRMEDI+STR(QPR_AMOSTR,1)
														If QPR->(DbSeek( xFilial("QPR") + cOp + "  " + SD3->D3_LOTECTL ))
															GravaQIP(cOP,SD3->D3_LOTECTL)
															lGravaCBC := .t.
														Else
															Aadd(aInconSub1,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD3->D3_LOTECTL,cProduto,cOP,"OP " + cOP + " do Lote " + SD3->D3_LOTECTL + " sem resultados"})
														Endif
													Else
														Aadd(aInconSub1,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD3->D3_LOTECTL,cProduto,cOP,"OP " + cOP + " empenhada nao foi localizada"})
													Endif
												Else
													lSD5 := .f.
													aInconSubX := {}
													
													SD5->(DbSetOrder(4))		//	D5_FILIAL+D5_OP+D5_NUMSEQ
													IF SD5->(DbSeek(xFilial("SD5") + SD3->D3_OP + SD3->D3_NUMSEQ))
														While xFilial("SD5") + SD3->D3_OP + SD3->D3_NUMSEQ ==;
															SD5->D5_FILIAL + SD5->D5_OP + SD5->D5_NUMSEQ .and. ;
															! SD5->(Eof())
															If SD5->D5_PRODUTO <> cProduto
																SD5->(DbSkip())
																Loop
															Endif
															
															// Indice 9 da base estah sem o campo Produto, logo Seek Falha
															// Realizado tratamento abaixo para contornar
															lSC2 := .f.
															If SC2->(DbSeek(xFilial("SC2") + SD5->D5_LOTECTL + cProduto))
																While ! SC2->(Eof()) .and. xFilial("SC2")+ SD5->D5_LOTECTL == SC2->C2_FILIAL + SC2->C2_LOTECTL
																	If AllTrim(cProduto) <> AllTrim(SC2->C2_PRODUTO)
																		SC2->(DbSkip())
																		Loop
																	Endif
																	lSC2 := .t.
																	Exit
																Enddo
															Endif
															If lSC2
																cOp := SC2->(C2_NUM + C2_ITEM + C2_SEQUEN)
																DbSelectArea("QPR")
																QPR->(DbSetOrder(8)) 	// QPR_FILIAL+QPR_OP+QPR_LOTE+QPR_OPERAC+QPR_LABOR+QPR_ENSAIO+DTOS(QPR_DTMEDI)+QPR_HRMEDI+STR(QPR_AMOSTR,1)
																If QPR->(DbSeek( xFilial("QPR") + cOp + "  " + SD5->D5_LOTECTL ))
																	GravaQIP(cOP,SD5->D5_LOTECTL)
																	lGravaCBC	:= .t.
																	lSD5			:= .t.
																	Exit
																Else
																	Aadd(aInconSubX,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD5->D5_LOTECTL,cProduto,cOP,"OP " + cOP + " do Lote " + SD5->D5_LOTECTL + " sem resultados (SD5)"})
																Endif
															Else
																Aadd(aInconSubX,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD5->D5_LOTECTL,cProduto,cOP,"OP " + cOP + " empenhada nao foi localizada"})
															Endif
															SD5->(DbSkip())		
														Enddo
														
														// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
														// Ё Se nao validou nenhum SD5, gera inconsistencias        Ё
														// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
														If ! lSD5
															If !Empty(aInconSubX)
																For nConta := 1 To Len(aInconSubX)
																	Aadd(aInconSub1,{aInconSubX[nConta,1],aInconSubX[nConta,2],aInconSubX[nConta,3],aInconSubX[nConta,4],aInconSubX[nConta,5]})
																Next nConta
															Endif
														Endif
													Else
														Aadd(aInconSub1,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM," ",cProduto," ","Empenho foi realizado com lote em branco (SD3/SD5)"})
													Endif
												Endif
											Else
												Aadd(aInconSub1,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM," ",cProduto," ","Empenho nao localizado"})
											Endif
										Else
											Aadd(aInconSub1,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM," ",cProduto," ","Ordem de Producao nao localizada"})
										Endif
									Endif
								Endif
								
								DbSelectArea("SG1")
								SG1->(DbSkip())
							EndDo							
							If lGravaCBC
								// зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								// Ё Gravo um cabecalho para o item, pois conseguiu localizar resultados Ё
								// юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
								GravaCBC("QIP")
								
								// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								// Ё Inicia analise do proximo item da Nota Fiscal de Saida Ё
								// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
								DbSelectArea("SD2")
								SD2->(DbSkip())
								Loop
							Else
								lGravaCBC2 := .f.
								
								// здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								// Ё Nao localizou resultados para primeiro nivel, analisa o segundo nivel da estrutura Ё
								// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
								For nConta := 1 To Len(aEstrutura)
									If SG1->(DbSeek( xFilial("SG1") + aEstrutura[nConta]))
										While SG1->(!EOF()) .AND. ;
											AllTrim(SG1->G1_COD) == AllTrim(aEstrutura[nConta])
											If QP6->(DbSeek(xFilial("QP6") + SG1->G1_COMP))
												cProduto := ALLTRIM(SG1->G1_COMP)
												lNumeroPAPI := .T.
												cOp := ""
												
												// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
												// Ё O Lote do PA eh igual ao Lote do PI                    Ё
												// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
												DbSelectArea("SC2")
												SC2->(DbSetOrder(10))		// C2_FILIAL+C2_LOTECTL+C2_PRODUTO
												If SC2->(DbSeek( xFilial("SC2") + SD2->D2_LOTECTL))
													While SC2->(!EOF()) .AND. ;
														SC2->C2_LOTECTL == SD2->D2_LOTECTL
														IF AllTrim(SC2->C2_PRODUTO ) == cProduto
															cOP := AllTrim(SC2->C2_NUM) + AllTrim(SC2->C2_ITEM) + AllTrim(SC2->C2_SEQUEN)
															Exit
														Endif
														SC2->(DbSkip())
													Enddo
													If Empty(cOP)
														lNumeroPAPI := .f.
														
														//															Aadd(aInconSub2,{SD2->D2_DOC + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto," ","Lote " + SD2->D2_LOTECTL + " sem OP para o produto " + cProduto + " da estrutura (nivel 2)"})
														//				              							SG1->(DbSkip())
														//				              							Loop
														//															Endif
													Else
														DbSelectArea("QPR")
														QPR->(DbSetOrder(8)) 	// QPR_FILIAL+QPR_OP+QPR_LOTE+QPR_OPERAC+QPR_LABOR+QPR_ENSAIO+DTOS(QPR_DTMEDI)+QPR_HRMEDI+STR(QPR_AMOSTR,1)
														If QPR->(DbSeek( xFilial("QPR") + cOP + "  " + SD2->D2_LOTECTL ))
															GravaQIP(cOP,SD2->D2_LOTECTL)
															lGravaCBC2 := .t.
														Else
															Aadd(aInconSub2,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto,cOP,"OP " + cOP + " do Lote " + SD2->D2_LOTECTL + " sem resultados (nivel 2)"})
															
															// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
															// Ё Inicia analise do proximo item da estrutura            Ё
															// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
															SG1->(DbSkip())
															Loop
														Endif
													Endif
												Endif
												
												// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
												// Ё Nao encontrou OP de PI com o mesmo numero da OP do PA  Ё
												// Ё Ira analisar os lotes utilizados na OP para localizar  Ё
												// Ё qual lote de PI foi utilizado na fabricacao do PA e    Ё
												// Ё imprime os dados deste lote.                           Ё
												// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
												If ! lNumeroPaPi
													SC2->(DbSetOrder(10))		// C2_FILIAL+C2_LOTECTL+C2_PRODUTO
													If SC2->(DbSeek(xFilial("SC2") + SD2->D2_LOTECTL + SD2->D2_COD))
														SD3->(DbSetOrder(1))		//	D3_FILIAL+D3_OP+D3_COD+D3_LOCAL
														If SD3->(DbSeek(xFilial("SD3") + SC2->(C2_NUM + C2_ITEM + C2_SEQUEN + C2_ITEMGRD) + cProduto))
															If ! Empty(SD3->D3_LOTECTL)
																If SC2->(DbSeek(xFilial("SC2")+ SD3->D3_LOTECTL + cProduto))
																	cOp := SC2->(C2_NUM + C2_ITEM + C2_SEQUEN)
																	DbSelectArea("QPR")
																	QPR->(DbSetOrder(8)) 	// QPR_FILIAL+QPR_OP+QPR_LOTE+QPR_OPERAC+QPR_LABOR+QPR_ENSAIO+DTOS(QPR_DTMEDI)+QPR_HRMEDI+STR(QPR_AMOSTR,1)
																	If QPR->(DbSeek( xFilial("QPR") + cOp + "  " + SD3->D3_LOTECTL ))
																		GravaQIP(cOP,SD3->D3_LOTECTL)
																		lGravaCBC := .t.
																	Else
																		Aadd(aInconSub1,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD3->D3_LOTECTL,cProduto,cOP,"OP " + cOP + " do Lote " + SD3->D3_LOTECTL + " sem resultados"})
																	Endif
																Else
																	Aadd(aInconSub1,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD3->D3_LOTECTL,cProduto,cOP,"OP " + cOP + " empenhada nao foi localizada"})
																Endif
															Else
																SD5->(DbSetOrder(4))		//	D5_FILIAL+D5_OP+D5_NUMSEQ
																IF SD5->(DbSeek(xFilial("SD5") + SD3->D3_OP + SD3->D3_NUMSEQ))
																	lSD5 := .f.
																	aInconSubX := {}
																	While xFilial("SD5") + SD3->D3_OP + SD3->D3_NUMSEQ ==;
																		SD5->D5_FILIAL + SD5->D5_OP + SD5->D5_NUMSEQ .and. ;
																		! SD5->(Eof())
																		If SD5->D5_PRODUTO <> cProduto
																			SD5->(DbSkip())
																			Loop
																		Endif
																		
																		// Indice 9 da base estah sem o campo Produto, logo Seek Falha
																		// Realizado tratamento abaixo para contornar
																		lSC2 := .f.
																		If SC2->(DbSeek(xFilial("SC2") + SD5->D5_LOTECTL + cProduto))
																			While ! SC2->(Eof()) .and. ;
																				xFilial("SC2") + SD5->D5_LOTECTL == ;
																				SC2->C2_FILIAL + SC2->C2_LOTECTL
																				If AllTrim(cProduto) <> AllTrim(SC2->C2_PRODUTO)
																					SC2->(DbSkip())
																					Loop
																				Endif
																				lSC2 := .t.
																				Exit
																			Enddo
																		Endif
																		If lSC2
																			cOp := SC2->(C2_NUM + C2_ITEM + C2_SEQUEN)
																			DbSelectArea("QPR")
																			QPR->(DbSetOrder(8)) 	// QPR_FILIAL+QPR_OP+QPR_LOTE+QPR_OPERAC+QPR_LABOR+QPR_ENSAIO+DTOS(QPR_DTMEDI)+QPR_HRMEDI+STR(QPR_AMOSTR,1)
																			If QPR->(DbSeek( xFilial("QPR") + cOp + "  " + SD5->D5_LOTECTL ))
																				GravaQIP(cOP,SD5->D5_LOTECTL)
																				lGravaCBC := .t.
																				lSD5 := .t.
																				Exit
																			Else
																				Aadd(aInconSubX,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD5->D5_LOTECTL,cProduto,cOP,"OP " + cOP + " do Lote " + SD5->D5_LOTECTL + " sem resultados (SD5)"})
																			Endif
																		Else
																			Aadd(aInconSubX,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD5->D5_LOTECTL,cProduto,cOP,"OP " + cOP + " empenhada nao foi localizada"})
																		Endif
																		SD5->(DbSkip())
																	Enddo
																	
																	// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
																	// Ё Se nao validou nenhum SD5, gera inconsistencias        Ё
																	// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
																	If ! lSD5
																		If !Empty(aInconSubX)
																			For nConta := 1 To Len(aInconSubX)
																				Aadd(aInconSub1,{aInconSubX[nConta,1],aInconSubX[nConta,2],aInconSubX[nConta,3],aInconSubX[nConta,4],aInconSubX[nConta,5]})
																			Next nConta
																		Endif
																	Endif
																Else
																	Aadd(aInconSub1,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM," ",cProduto," ","Empenho foi realizado com lote em branco (SD3/SD5)"})
																Endif
															Endif
														Else
															Aadd(aInconSub1,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM," ",cProduto," ","Empenho nao localizado"})
														Endif
													Else
														Aadd(aInconSub1,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM," ",cProduto," ","Ordem de Producao nao localizada"})
													Endif
												Endif
											Endif
											
											DbSelectArea("SG1")
											SG1->(DbSkip())
										EndDo
									Endif	// Localiza Estrutura de Segundo Nivel
								Next nConta
							Endif
							
							// Grava Inconsistencias do nivel 2 ou nivel 1
							If ! lGravaCBC2
								lProximo := .f.
								If ! Empty(aInconSub2)
									lProximo := .t.
									For nConta := 1 To Len(aInconSub2)
										Aadd(aIncon,{aInconSub2[nConta,1],aInconSub2[nConta,2],aInconSub2[nConta,3],aInconSub2[nConta,4],aInconSub2[nConta,5]})
									Next nConta
								Endif
								If ! Empty(aInconSub1)
									lProximo := .t.
									For nConta := 1 To Len(aInconSub1)
										Aadd(aIncon,{aInconSub1[nConta,1],aInconSub1[nConta,2],aInconSub1[nConta,3],aInconSub1[nConta,4],aInconSub1[nConta,5]})
									Next nConta
								Endif
								If lProximo
									// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
									// Ё Inicia analise do proximo item da Nota Fiscal de Saida Ё
									// Ё Pois ja logou inconsistencia                           Ё
									// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
									DbSelectArea("SD2")
									SD2->(DbSkip())
									Loop
								Endif
							Else								
								// зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								// Ё Gravo um cabecalho para o item, pois conseguiu localizar resultados Ё
								// юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
								GravaCBC("QIP")
								// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								// Ё Inicia analise do proximo item da Nota Fiscal de Saida Ё
								// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
								DbSelectArea("SD2")
								SD2->(DbSkip())
								Loop
							Endif
						Endif						
						
						// зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						// Ё 2. Verifica se existe Especificacao, Entrega e Resultado Deste Lote   Ё
						// Ё no Modulo de Inspecao de Entregas                                     Ё
						// юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						
						DbSelectArea("QE6")
						QE6->(DbSetOrder(1))
						If QE6->(DbSeek( xFilial("QE6") + SD2->D2_COD))
							cProduto := ALLTRIM(SD2->D2_COD)
							
							DbSelectArea("QEK")
							QEK->(DbSetOrder(6))		// QEK_FILIAL + QEK_LOTE
							// зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							// Ё Tera que localizar uma entrada deste lote, desconsiderando os Ё
							// Ё sub-lotes do mesmo. Pela qualidade, todos os sub-lotes deste  Ё
							// Ё lote, possuem os mesmos resultados.                           Ё
							// юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
							
							nCasas 	:= Len(AllTrim(SD2->D2_LOTECTL))
							cLote	:= ""
							If QEK->(DbSeek( xFilial("QEK") + AllTrim(SD2->D2_LOTECTL)))
								While QEK->(!Eof()) .and. ;
									QEK->QEK_FILIAL == xFilial("QEK") .and. ;
									Substr(QEK->QEK_LOTE,1,nCasas) == AllTrim(SD2->D2_LOTECTL)
									//If Len(AllTrim(QEK->QEK_LOTE)) == nCasas + 6 .and. ;	// 6 posicoes de Sub-Lote
									//	QEK->QEK_PRODUT == SD2->D2_COD
									IF alltrim(QEK->QEK_LOTE) == alltrim(SD2->D2_LOTECTL) .AND. QEK->QEK_PRODUT == SD2->D2_COD
										cLote := QEK->QEK_LOTE
										cChave:= QEK->(QEK_PRODUT+QEK_REVI+QEK_FORNEC+QEK_LOJFOR+DTOS(QEK_DTENTR)+QEK_LOTE)
										Exit
									Endif
									QEK->(DbSkip())
								Enddo
							Endif
							If ! Empty(cLote )
								DbSelectArea("QER")
								QER->(DbSetOrder(1)) 	// QER_FILIAL+QER_PRODUT+QER_REVI+QER_FORNEC+QER_LOJFOR+DTOS(QER_DTENTR)+QER_LOTE+QER_LABOR+QER_ENSAIO+DTOS(QER_DTMEDI)+QER_HRMEDI+STR(QER_AMOSTR,1)
								If QER->(DbSeek( xFilial("QER") + cChave ))
									If GravaCBC("QIE")
										GravaQIE(cChave)
									Endif
									// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
									// Ё Inicia analise do proximo item da Nota Fiscal de Saida Ё
									// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
									DbSelectArea("SD2")
									SD2->(DbSkip())
									Loop
								Else
									Aadd(aIncon,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto,cLote,"Entrega do lote " + cLote + " sem resultados"})
									// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
									// Ё Inicia analise do proximo item da Nota Fiscal de Saida Ё
									// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
									DbSelectArea("SD2")
									SD2->(DbSkip())
									Loop
								Endif
							Else
								Aadd(aIncon,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto," ","Entrega nЦo localizada do Lote " + SD2->D2_LOTECTL})
								// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								// Ё Inicia analise do proximo item da Nota Fiscal de Saida Ё
								// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
								DbSelectArea("SD2")
								SD2->(DbSkip())
								Loop
							Endif
						Else
							//verifica pelo PI 
						    cCodPIAx:= ""
							DbSelectArea("SG1")
							DbSetOrder(1)
							MsSeek(xFilial("SG1")+SD2->D2_COD)
							While !Eof() .And. SG1->G1_COD==SD2->D2_COD
								If AllTrim(Posicione("SB1",1,xFilial("SB1")+SG1->G1_COMP,"B1_TIPO"))=="4"
									cCodPIAx:= SG1->G1_COMP								
								EndIf	
								DbSelectArea("SG1")
								DbSkip()
							EndDo

							DbSelectArea("QE6")
							QE6->(DbSetOrder(1))
							If QE6->(DbSeek( xFilial("QE6") + cCodPIAx))
								cProduto := ALLTRIM(SD2->D2_COD) //cCodPIAx)
								
								DbSelectArea("QEK")
								QEK->(DbSetOrder(6))		// QEK_FILIAL + QEK_LOTE
								// зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								// Ё Tera que localizar uma entrada deste lote, desconsiderando os Ё
								// Ё sub-lotes do mesmo. Pela qualidade, todos os sub-lotes deste  Ё
								// Ё lote, possuem os mesmos resultados.                           Ё
								// юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
								nCasas 	:= Len(AllTrim(SD2->D2_LOTECTL))
								cLote	:= ""
								If QEK->(DbSeek( xFilial("QEK") + AllTrim(SD2->D2_LOTECTL)))
									While QEK->(!Eof()) .and. ;
										QEK->QEK_FILIAL == xFilial("QEK") .and. ;
										Substr(QEK->QEK_LOTE,1,nCasas) == AllTrim(SD2->D2_LOTECTL)
										If Len(AllTrim(QEK->QEK_LOTE)) == nCasas + 6 .and. ;	// 6 posicoes de Sub-Lote
											QEK->QEK_PRODUT == SD2->D2_COD
											cLote := QEK->QEK_LOTE
											cChave := QEK->(QEK_PRODUT+QEK_REVI+QEK_FORNEC+QEK_LOJFOR+DTOS(QEK_DTENTR)+QEK_LOTE)
											Exit
										Endif
										QEK->(DbSkip())
									Enddo
								Endif
								If ! Empty(cLote )
									DbSelectArea("QER")
									QER->(DbSetOrder(1)) 	// QER_FILIAL+QER_PRODUT+QER_REVI+QER_FORNEC+QER_LOJFOR+DTOS(QER_DTENTR)+QER_LOTE+QER_LABOR+QER_ENSAIO+DTOS(QER_DTMEDI)+QER_HRMEDI+STR(QER_AMOSTR,1)
									If QER->(DbSeek( xFilial("QER") + cChave ))
										If GravaCBC("QIE")
											GravaQIE(cChave)
										Endif
										// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										// Ё Inicia analise do proximo item da Nota Fiscal de Saida Ё
										// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
										DbSelectArea("SD2")
										SD2->(DbSkip())
										Loop
									Else
										Aadd(aIncon,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto,cLote,"Entrega do lote " + cLote + " sem resultados"})
										// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										// Ё Inicia analise do proximo item da Nota Fiscal de Saida Ё
										// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
										DbSelectArea("SD2")
										SD2->(DbSkip())
										Loop
									Endif
								Else
									Aadd(aIncon,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto," ","Entrega nЦo localizada do Lote " + SD2->D2_LOTECTL})
									// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
									// Ё Inicia analise do proximo item da Nota Fiscal de Saida Ё
									// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
									DbSelectArea("SD2")
									SD2->(DbSkip())
									Loop
								Endif
							EndIf
						Endif
						
						// здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						// Ё Gerar Inconsistencia, pois nao atendeu nenhuma regra acima Ё
						// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						Aadd(aIncon,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,SD2->D2_COD," ","Lote nЦo atendeu nenhuma regra"})
						// здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						// Ё Inicia analise do proximo item da Nota Fiscal de Saida Ё
						// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						DbSelectArea("SD2")
						SD2->(DbSkip())
					ENDDO
				ENDIF
			ENDIF
		ELSE
			MSGBOX("CLIENTE NAO ENCONTRADO")
			DBSELECTAREA("SF2")
			SF2->(DbSkip())
		ENDIF		
		// здддддддддддддддддддддддддддддддддддддддддддддддд©
		// Ё Inicia analise da proxima Nota Fiscal de Saida Ё
		// юдддддддддддддддддддддддддддддддддддддддддддддддды
		DBSELECTAREA("SF2")
		DBSKIP()
	ENDDO
	//	ELSE     dan
	//	MSGBOX("NOTA FISCAL INICIAL NAO ENCONTRADA")  dan
	//	ENDIF          dan
	
	CursorArrow()
	
	// здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	// Ё Chama rotina de impressao das inconsistencias e envia as mesmas por e-mail Ё
	// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If ! Empty(aIncon)
		U_LogIncon()
		EnviaIncon()
	Endif
	
	// зддддддддддддддддддддддддддддддддддддддддддддд©
	// Ё Chama rotina de impressao dos certificados  Ё
	// юддддддддддддддддддддддддддддддддддддддддддддды
	U_IMPRCERT()
Endif

CBC->(DBCLOSEAREA())
FERASE(_cArqCbc)
ITEM->(DBCLOSEAREA())
FERASE(_cArqItm)
RESUL->(DBCLOSEAREA())
FERASE(_cArqRes)

RETURN(.T.)

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммкмммммммяммммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Programa  ЁGravaQIP  ╨Autor  ЁRogerio Nagy        ╨ Data Ё  02/06/06   ╨╠╠
╠╠лммммммммммьммммммммммймммммммоммммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Desc.     Ё Grava dados do certificado de um determinado Lote, Produto ╨╠╠
╠╠╨          Ё                                                            ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё AP                                                         ╨╠╠
╠╠хммммммммммомммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function GravaQIP(cOp,cLote)

// здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
// Ё Guarda valores temporarios do certificado com dados do Inspecao de Processos Ё
// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды

DBSELECTAREA("QPR")
QPR->(DbSetOrder(8)) 	// QPR_FILIAL+QPR_OP+QPR_LOTE+QPR_OPERAC+QPR_LABOR+QPR_ENSAIO+DTOS(QPR_DTMEDI)+QPR_HRMEDI+STR(QPR_AMOSTR,1)
If QPR->(DbSeek( xFilial("QPR") + cOP + "  " + cLote ))
	//IF ALLTRIM(cOP) == ALLTRIM(QPR->QPR_OP) // INCLUIDO APOS ALTERACAO DE IF DBSEEK
	WHILE !EOF() .AND. ALLTRIM(QPR->QPR_OP) == ALLTRIM(cOP) .and. ;
		Substr(QPR->QPR_LOTE,1,10) == cLote
		
		DBSELECTAREA("RESUL")
		RECLOCK("RESUL",.T.)
		RESUL->NOTA   := ALLTRIM(SF2->F2_DOC)
		RESUL->SERIE  := ALLTRIM(SF2->F2_SERIE)
		RESUL->PRODUTO:= ALLTRIM(SD2->D2_COD)
		RESUL->ITEM   := SD2->D2_ITEM
		RESUL->LOTE   := ALLTRIM(SD2->D2_LOTECTL)
		RESUL->ENSAIO := ALLTRIM(QPR->QPR_ENSAIO)
		cChave        := ALLTRIM(QPR->QPR_CHAVE)
		
		DBSELECTAREA("QP1")
		DBSETORDER(1)
		IF DBSEEK( XFILIAL("QP1") + QPR->QPR_ENSAIO )
			RESUL->NOME := QP1->QP1_DESCPO
		ENDIF
		
		DBSELECTAREA("QP8")
		DBSETORDER(3)
		IF DBSEEK( XFILIAL("QP8") + QPR->QPR_ENSAIO + cProduto )
			Do while !EOF() .AND. QPR->QPR_ENSAIO == QP8->QP8_ENSAIO .AND. ALLTRIM(cProduto) == ALLTRIM (QP8->QP8_PRODUT)
				IF QPR->QPR_REVI == QP8->QP8_REVI
					RESUL->ESPEC := ALLTRIM(QP8->QP8_TEXTO)
					DBSKIP()
				ELSE
					DBSKIP()
				ENDIF
			ENDDO
			
			DBSELECTAREA("QPQ")
			DBSETORDER(1)
			IF DBSEEK( XFILIAL("QPS") + cChave )
				RESUL->RESULT  := ALLTRIM(QPQ->QPQ_MEDICA)
			ENDIF
			MSUNLOCK()
		ELSE
			DBSELECTAREA("QP7")
			DBSETORDER(3)
			QP7->(DBGOTOP())
			IF DBSEEK( XFILIAL("QP7") + QPR->QPR_ENSAIO + cProduto)
				Do while !EOF() .AND. QPR->QPR_ENSAIO == QP7->QP7_ENSAIO .AND. ALLTRIM(cProduto) == ALLTRIM (QP7->QP7_PRODUT)
					IF QPR->QPR_REVI == QP7->QP7_REVI
						RESUL->ESPEC := ALLTRIM(QP7->QP7_LIE)+ " / " + ALLTRIM(QP7->QP7_LSE)
						DBSKIP()
					ELSE
						DBSKIP()
					ENDIF
				ENDDO
				DBSELECTAREA("QPS")
				DBSETORDER(1)
				IF DBSEEK( XFILIAL("QPS") + cChave ) //1
					RESUL->RESULT := QPS->QPS_MEDICA
					MSUNLOCK()
				ENDIF //1
			ENDIF
		ENDIF
		DBSELECTAREA("QPR")
		DBSKIP()
	ENDDO
ELSE
	MSGBOX("OP "+cOP+" DO PRODUTO:"+ cProduto +", NAO ENCONTRADA NOS RESULTADOS, POR FAVOR, CRIAR O MESMO MANUALMENTE") //Alterado apos acerto de QPR
ENDIF

Return .t.


/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммкмммммммяммммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Programa  ЁGravaQIE  ╨Autor  ЁRogerio Nagy        ╨ Data Ё  02/06/06   ╨╠╠
╠╠лммммммммммьммммммммммймммммммоммммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Desc.     ЁGrava dados do certificado de um determinado lote.          ╨╠╠
╠╠╨          Ё                                                            ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё AP                                                        ╨╠╠
╠╠хммммммммммомммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function GravaQIE(cChave)

Local cChaveQE := ""

// здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
// Ё Guarda valores temporarios do certificado com dados do Inspecao de Entregas  Ё
// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды

DbSelectArea("QER")
QER->(DbSetOrder(1))
If QER->(DbSeek( xFilial("QER") + cChave ))
	While QER->(!EOF()) .AND. ;
		cChave == QER->(QER_PRODUT+QER_REVI+QER_FORNEC+QER_LOJFOR+DTOS(QER_DTENTR)+QER_LOTE)
		
		DbSelectArea("RESUL")
		RecLock("RESUL",.T.)
		RESUL->NOTA   := AllTrim(SF2->F2_DOC)
		RESUL->SERIE  := AllTrim(SF2->F2_SERIE)
		RESUL->PRODUTO:= AllTrim(SD2->D2_COD)
		RESUL->ITEM   := SD2->D2_ITEM
		RESUL->LOTE   := AllTrim(SD2->D2_LOTECTL)
		RESUL->ENSAIO := AllTrim(QER->QER_ENSAIO)
		cChaveQE      := AllTrim(QER->QER_CHAVE)
		
		DbSelectArea("QE1")
		QE1->(DbSetOrder(1))
		If QE1->(DbSeek( xFilial("QE1") + QER->QER_ENSAIO ))
			RESUL->NOME := QE1->QE1_DESCPO
		Endif
		
		DbSelectArea("QE8")
		QE8->(DbSetOrder(3))  // QE8_FILIAL+QE8_ENSAIO+QE8_PRODUT+QE8_REVI
		If QE8->(DbSeek( xFilial("QE8") + QER->QER_ENSAIO + cProduto ))
			While QE8->(!EOF()) .AND. ;
				QER->QER_ENSAIO == QE8->QE8_ENSAIO .AND. ;
				AllTrim(cProduto) == AllTrim (QE8->QE8_PRODUT)
				If QER->QER_REVI == QE8->QE8_REVI
					RESUL->ESPEC := AllTrim(QE8->QE8_TEXTO)
				Endif
				QE8->(DBSkip())
			Enddo
			
			DbSelectArea("QEQ")
			QEQ->(DbSetOrder(1))
			If QEQ->(DbSeek( xFilial("QEQ") + cChaveQE ))
				RESUL->RESULT  := ALLTRIM(QEQ->QEQ_MEDICA)
			Endif
			MSUNLOCK()
		Else
			DbSelectArea("QE7")
			QE7->(DbSetOrder(3))  	// QE7_FILIAL+QE7_ENSAIO+QE7_PRODUT+QE7_REVI
			//QE7->(DBGOTOP())
			If QE7->(DbSeek( xFilial("QE7") + QER->QER_ENSAIO + cProduto))
				While QE7->(!EOF()) .AND. ;
					QER->QER_ENSAIO == QE7->QE7_ENSAIO .AND. ;
					AllTrim(cProduto) == AllTrim (QE7->QE7_PRODUT)
					If QER->QER_REVI == QE7->QE7_REVI
						RESUL->ESPEC := AllTrim(QE7->QE7_LIE)+ " / " + AllTrim(QE7->QE7_LSE)
					Endif
					QE7->(DBSkip())
				Enddo
				
				DbSelectArea("QES")
				QES->(DbSetOrder(1))		//QES_FILIAL+QES_CODMED
				If QES->(DbSeek( xFilial("QES") + cChaveQE ))
					RESUL->RESULT := QES->QES_MEDICA
				Endif
				MSUNLOCK()
			Endif
		Endif
		DbSelectArea("QER")
		QER->(DbSkip())
	Enddo
Endif

Return .t.

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммкмммммммяммммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Programa  ЁGravaCBC  ╨Autor  ЁRogerio Nagy        ╨ Data Ё  02/06/06   ╨╠╠
╠╠лммммммммммьммммммммммймммммммоммммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Desc.     ЁGrava Cabecalho e Itens do Certificado                      ╨╠╠
╠╠╨          Ё                                                            ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё AP                                                         ╨╠╠
╠╠хммммммммммомммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function GravaCBC(cModulo)

Local lRet 	:= .T.
Local dData := Ctod("  /  /  ")

DbSelectArea("SB1")
DbSetOrder(1)
DbSeek( xFilial("SB1") + SD2->D2_COD )
If cModulo == "QIE"
	// здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	// Ё Valida se Data de Fabricacao calculada eh maior que a data atual             Ё
	// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	
	// здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	// Ё Localiza Nota Fiscal de Entrada deste Lote                                   Ё
	// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	SD1->(DbSetOrder(4))		// D1_FILIAL+D1_NUMSEQ
	If SD1->(DbSeek(xFilial("SD1") + QEK->QEK_NUMSEQ))
		If Empty(SD1->D1_DTVALID)
			Aadd(aIncon,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto,cLote,"Data de validade em branco na NF de entrada"})
			Return .f.
		Endif
		dData	:= SD1->D1_DTVALID - (SB1->B1_MESVALI * 30)
	Endif
	If dData > dDataBase
		Aadd(aIncon,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto,cLote,"Data de fabricacao calculada " + Dtoc(dData) +  " superior a data base"})
		Return .f.
	Endif
Endif

DBSELECTAREA("CBC")
RECLOCK("CBC",.T.)
CBC->NOTA     := ALLTRIM(SF2->F2_DOC)
CBC->SERIE    := ALLTRIM(SF2->F2_SERIE)
CBC->CLIENTE  := ALLTRIM(SF2->F2_CLIENTE)
CBC->LOJA     := ALLTRIM(SF2->F2_LOJA)
CBC->NOME     := ALLTRIM(SA1->A1_NOME)
CBC->EMISSAO  := SF2->F2_EMISSAO
CBC->PRODUTO  := ALLTRIM(SD2->D2_COD)
CBC->ITEM     := SD2->D2_ITEM
MSUNLOCK()

DBSELECTAREA("ITEM")
RECLOCK("ITEM",.T.)
ITEM->NOTA     := ALLTRIM(SF2->F2_DOC)
ITEM->SERIE    := ALLTRIM(SF2->F2_SERIE)
ITEM->PRODUTO  := ALLTRIM(SD2->D2_COD)
ITEM->ITEM     := SD2->D2_ITEM
ITEM->DESC  	:= ALLTRIM(SB1->B1_DESC)
ITEM->UM       := ALLTRIM(SD2->D2_UM)
ITEM->QUANT    := SD2->D2_QUANT
ITEM->LOTE     := ALLTRIM(SD2->D2_LOTECTL)
If cModulo == "QIP"
	// здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	// Ё Imprime Data de Fabricacao e Validade conforme Ordem de Producao             Ё
	// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	DBSELECTAREA("SC2")
	DBSETORDER(10)    // C2_FILIAL+C2_LOTECTL+C2_PRODUTO
	IF DBSEEK( xFilial("SC2") + SD2->D2_LOTECTL)
		//ITEM->FABRI := SC2->C2_EMISSAO RODOLFO A PEDIDO DO FABIO PCP FOI TROCADO PELA C2_DATPRINI 27/12
		ITEM->FABRI := SC2->C2_DATPRI
	ENDIF
	
	DBSELECTAREA("SB8")
	DBSETORDER(6)
	IF DBSEEK( XFILIAL("SB8") + SD2->D2_LOTECTL)
		ITEM->DTVALID := SB8->B8_DTVALID
	ENDIF
Else
	// здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	// Ё Imprime Data de Validade informada na Nota Fiscal de Entrada                 Ё
	// Ё Imprime Data de Fabricacao com Data de Validade Menos Periodo de Validade do Ё
	// Ё Produto                                                                      Ё
	// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	
	// здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	// Ё Localiza Nota Fiscal de Entrada deste Lote                                   Ё
	// юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	SD1->(DbSetOrder(4))		// D1_FILIAL+D1_NUMSEQ
	If SD1->(DbSeek(xFilial("SD1") + QEK->QEK_NUMSEQ))
		ITEM->DTVALID 	:= SD1->D1_DTVALID
		ITEM->FABRI 	:= SD1->D1_DTVALID - (SB1->B1_MESVALI * 30)
	Endif
Endif

MSUNLOCK()

Return .t.

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммкмммммммяммммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Programa  ЁLogInco   ╨ Autor Ё Rogerio Nagy       ╨ Data Ё 06/02/2005  ╨╠╠
╠╠лммммммммммьммммммммммймммммммоммммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Descricao Ё Imprime Relacao de inconsistencias                         ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё Brascola                                                   ╨╠╠
╠╠хммммммммммомммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
/*/
User Function LogIncon()

//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Declaracao de Variaveis                                             Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды

Local   cDesc1     := "Este programa tem como objetivo imprimir relatorio "
Local   cDesc2     := "contendo as inconsistencias de certificados."
Local   cDesc3     := "Certificados Inconsistentes"
Local   cPict      := ""
Local   imprime    := .T.
Private aOrd       := {}
Private nLin       := 80
Private Cabec1     := "NF/Seq        Lote      Produto          OP                Inconsistencia"
Private Cabec2     := ""
Private lEnd       := .F.
Private lAbortPrint:= .F.
Private CbTxt      := ""
Private limite     := 132
Private tamanho    := "M"
Private nTipo      := 15
Private aReturn    := { "Zebrado", 1, "Administracao", 1, 2, 1, "", 1}
Private nLastKey   := 0
Private cbtxt      := Space(10)
Private cbcont     := 00
Private CONTFL     := 01
Private m_pag      := 01
Private wnrel      := "CERTQUA3"
Private cString    := ""
Private nomeprog   := "CERTQUA3"
Private aLinha     := { },nLastKey := 0
Private cPerg      := ""
Private Titulo     := "RELACAO DE CERTIFICADOS INCONSISTENTES"

//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Monta a interface padrao com o usuario...                           Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды

//wnrel := SetPrint(cString,NomeProg,"",titulo,cDesc1,cDesc2,cDesc3,.F.,aOrd,.F.,Tamanho,,.F.)
wnrel:= SetPrint(cString,wnrel,"",Titulo,cDesc1,cDesc2,cDesc3,.f.)

If nLastKey == 27
	Return
Endif

SetDefault(aReturn,cString)

If nLastKey == 27
	Return
Endif

nTipo := If(aReturn[4]==1,15,18)

//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Processamento. RPTSTATUS monta janela com a regua de processamento. Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды

//RptStatus({|| RunReport(Cabec1,Cabec2,Titulo,nLin,NomeProg,Tamanho,nTipo) },Titulo)

//Processa({ || U_GeraCert(Cabec1,Cabec2,Titulo,nLin,NomeProg,Tamanho,nTipo)}, Titulo,,.t.)
Processa({ || U_GeraCert()}, Titulo,,.t.)

Return  .t.

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммкмммммммяммммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Fun┤└o    ЁRUNREPORT ╨ Autor Ё Rogerio Nagy       ╨ Data Ё 06/02/2006  ╨╠╠
╠╠лммммммммммьммммммммммймммммммоммммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Descri┤└o Ё Funcao auxiliar chamada pela RPTSTATUS. A funcao RPTSTATUS ╨╠╠
╠╠╨          Ё monta a janela com a regua de processamento.               ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё Programa CERT2                                             ╨╠╠
╠╠хммммммммммомммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
/*/
User Function GeraCert() //Cabec1,Cabec2,Titulo,nLin,NomeProg,Tamanho,nTipo)
************************
//Local nOrdem
Local nConta

//SetRegua(Len(aIncon))
ProcRegua(Len(aIncon))

For nConta := 1 To Len(aIncon)	
	//IncRegua()
	IncProc()
	
	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica o cancelamento pelo usuario...                             Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	
	If lAbortPrint
		@nLin,00 PSAY "*** CANCELADO PELO OPERADOR ***"
		Exit
	Endif
	
	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Impressao do cabecalho do relatorio. . .                            Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	
	If nLin > 55 // Salto de PАgina. Neste caso o formulario tem 55 linhas...
		//Cabec(Titulo,Cabec1,/*Cabec2*/" ",NomeProg,/*Tamanho*/1,/*nTipo*/15)
		nLin:= Cabec(Titulo,Cabec1,Cabec2,NomeProg,Tamanho,nTipo,,.F.)
		nLin++
	Endif
	
	@ nLin, 000 PSAY AllTrim(aIncon[nConta,1])
	@ nLin, 013 PSAY aIncon[nConta,2]
	@ nLin, 025 PSAY aIncon[nConta,3]
	@ nLin, 038 PSAY aIncon[nConta,4]
	@ nLin, 056 PSAY aIncon[nConta,5]
	nLin++
	
Next nConta

//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Finaliza a execucao do relatorio...                                 Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды

SET DEVICE TO SCREEN

//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Se impressao em disco, chama o gerenciador de impressao...          Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If aReturn[5]==1
	dbCommitAll()
	SET PRINTER TO
	OurSpool(wnrel)
Endif
MS_FLUSH()

Return .t.

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммкмммммммяммммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Programa  ЁEnviaIncon╨Autor  ЁRogerio Nagy        ╨ Data Ё  02/07/06   ╨╠╠
╠╠лммммммммммьммммммммммймммммммоммммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Desc.     Ё Envia inconsistencias encontradas por e-mail               ╨╠╠
╠╠╨          Ё                                                            ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё Brascola                                                  ╨╠╠
╠╠хммммммммммомммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function EnviaIncon

Local _cServer := GetMV("MV_RELSERV")   	// Servidor
Local _cConta  := GetMV("MV_RELACNT")   	// Conta
Local _cPass   := GetMV("MV_RELPSW")   	// Senha da conta
Local _cResp   := GetMv("BR_EMCERTI")		// Responsavel pelas inconsistencias do certificado
Local _cBody	:= " "
Local _cErro 	:= ""
Local lOk 		:= .t.

_cBody    :="<HTML>"
_cBody    += "<HEAD><TITLE> InconsistЙncias encontradas na emissЦo de certificados da qualidade</TITLE></HEAD>"
_cBody    += "<BODY>"
_cBody    +="<p style=line-height: 100%; margin-top: 0; margin-bottom: 0></p>"
_cBody    +="<P> </P>"
_cBody    +="<P> </P>"
_cBody    +="<P> </P>"
_cBody    +="<P> Favor verificar inconsistЙncias encontradas abaixo" + "</P>"
_cBody    +="<P> </P>"
_cBody    +="<P> </P>"
_cBody    += "<table bordercolor=#0099cc height=15 cellspacing=1 width=620 bordercolorlight=#0099cc  border=1>"
_cBody    += '<tr><td align=center width=065 height=15><font face="Arial Black" size=1>Nota Fiscal</font></td>'
_cBody    += '    <td align=center width=100 height=15><font face="Arial Black" size=1>Lote</font></td>'
_cBody    += '    <td align=center width=110 height=15><font face="Arial Black" size=1>Produto</font></td>'
_cBody    += '    <td align=center width=90 height=15><font face="Arial Black" size=1>OP</font></td>'
_cBody    += '    <td align=center width=350 height=15><font face="Arial Black" size=1>InconsistЙncia</font></td>'

For nConta := 1 To Len(aIncon)
	_cBody += '<tr><td align=center width=065 height=15> <font face="Arial" size=1>'+ aIncon[nConta,1]+'</font></td>'
	_cBody += '    <td align=center width=100 height=15> <font face="Arial" size=1>'+ Iif(Empty(aIncon[nConta,2]),"-",aIncon[nConta,2])+'</font></td>'
	_cBody += '    <td align=center width=110 height=15> <font face="Arial" size=1>'+ Iif(Empty(aIncon[nConta,3]),"-",aIncon[nConta,3])+'</font></td>'
	_cBody += '    <td align=center width=090 height=15> <font face="Arial" size=1>'+ Iif(Empty(aIncon[nConta,4]),"-",aIncon[nConta,4])+'</font></td>'
	_cBody += '    <td align=center width=350 height=15> <font face="Arial" size=1>'+ Iif(Empty(aIncon[nConta,5]),"-",aIncon[nConta,5])+'</font></td></tr>'
Next nConta

_cBody    +="</table>"
_cBody    +="<P> </P>"
_cBody    +="<P> </P>"
_cBody    +="<P> </P>"
_cBody    +="<P> E-mail gerado pelo mСdulo Quality em " + dtoc(ddatabase) + "as " + Left(Time(),5) + "</P>"
_cBody    += "</BODY>"
_cBody    +="</HTML>"+"<P> </P>"+"<P> </P>"+"<P> </P>"

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Envia e-mail para aviso de Inconsistencia                        Ё
//ддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
CONNECT SMTP SERVER _cServer ACCOUNT _cConta PASSWORD _cPass RESULT lOk

If lOk
	//Envio de e-mail HTML
	SEND MAIL FROM _cConta ;
	TO _cResp ;
	SUBJECT 'InconsistЙncia na emissЦo de Certificados de Qualidade' ;
	BODY _cBody ;
	RESULT lOk
	If !lOk
		//Erro no Envio do e-mail
		GET MAIL ERROR cError
		MsgInfo(cError,OemToAnsi("Erro no envio de e-mail"))
	EndIf
Else
	//Erro na conexao com o SMTP Server
	GET MAIL ERROR cError
	MsgInfo(cError,OemToAnsi("Erro na conexЦo com o servidor de e-mail"))
EndIf

DISCONNECT SMTP SERVER

Return .T.
