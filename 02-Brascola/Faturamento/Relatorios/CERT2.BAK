#Include "RWMAKE.CH"
#Include "Protheus.ch"                        
#Include "ap5mail.ch"

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³CERT2     ºAutor  ³Microsiga           º Data ³  02/06/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Impressao de Certificados de Qualidade                      º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Brascola                                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ BR_EMCERT - E-mail que sera notificado das inconsistencias º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRogerio   ³ Implementacao de melhorias na rotina                       º±±
±±º06/02/06  ³ - Permitir impressao de Certificados diretamente do modulo º±±
±±º          ³de inspecao de entregas                                     º±±
±±º          ³ - Permitir impressao de itens de segundo nivel na estruturaº±±
±±º          ³quando nao encontrar no primeiro nivel                      º±±
±±º          ³ - Imprimir relatorio final com inconsistencias em vez de   º±±
±±º          ³certificados parciais inconsistentes.                       º±±
±±ºElias Reis³ - Permitir impressao de certificados de itens da NF, para oº±±
±±º30/08/06  ³   caso de o usuario ja ter impresso o certificado de algum º±±
±±º          ³   item, e nao ter que repetir a impressao de todos novamentº±±
±±º          ³   e.                                                       º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

USER FUNCTION CERTQUA2()

Local aRegs         := {}
Local cOP           := ""
Local cChave        := ""
Local cPerg         := "CTFQLD"                 					
Local _aCBC         := {}
Local _aItem 		:= {}
Local _aResul		:= {}
Local lGravaCBC	    := .f.
Local aInconSub1 	:= {}
Local aInconSub2 	:= {}
Local aEstrutura	:= {}
Local nCasas
Private cProduto    := ""
Private aIncon      := {}
Private cLote       := ""

// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³ Prepara perguntas de filtro para emissao do(s) Certificado(s)  ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
AADD(aRegs,{cPerg,"01","NF Inicial         ?"," "," ","mv_ch1","C",09,0,0,"G","","mv_par01"})
AADD(aRegs,{cPerg,"02","NF Final           ?"," "," ","mv_ch2","C",09,0,0,"G","","mv_par02"})
AADD(aRegs,{cPerg,"03","Serie              ?"," "," ","mv_ch3","C",03,0,0,"G","","mv_par03"})
AADD(aRegs,{cPerg,"04","Produto        	   ?"," "," ","mv_ch4","C",15,0,0,"G","","mv_par04"})
//AADD(aRegs,{ALLTRIM(cPerg),"05","Item Final         ?"," "," ","mv_ch5","C",2,0,0,"G","","mv_par05"})

// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³ Cria as perguntas, caso nao as encontre no SX1                 ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//dbSelectArea("SX1")
//For i:=1 to Len(aRegs)
//	If !dbSeek(cPerg+aRegs[i,2])
//		RecLock("SX1",.T.)
//		For j:=1 to FCount()
//			FieldPut(j,aRegs[i,j])
//		Next
//		MsUnlock()
//		dbCommit()
//	Endif
//Next

Pergunte(cPerg,.f.)
lValidPerg(aRegs)

// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³ Cria arquivo temporario com cabecalho do certificado (CBC)     ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Aadd(_aCBC,{"NOTA"         ,"C",009,0})
Aadd(_aCBC,{"SERIE"        ,"C",003,0})
Aadd(_aCBC,{"CLIENTE"      ,"C",008,0})
Aadd(_aCBC,{"LOJA"         ,"C",004,0})
Aadd(_aCBC,{"PRODUTO"      ,"C",015,0})
Aadd(_aCBC,{"ITEM"         ,"C",004,0})
Aadd(_aCBC,{"NOME"         ,"C",040,0})
Aadd(_aCBC,{"EMISSAO"      ,"D",008,0})

_cArqCbc := CriaTrab(_aCBC,.T.)

//Verifica se o Alias já está aberto, antes de abrir novamente
//Elias 08/02/2006
If Select("CBC") > 0
	dbCloseArea("CBC")
EndIF

dbUseArea( .T.,,_cArqCbc, "CBC", .F., .F. )

// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³ Cria arquivo temporario com itens do certificado (ITEM)     ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Aadd(_aItem,{"NOTA"         ,"C",009,0})
Aadd(_aItem,{"SERIE"        ,"C",003,0})
Aadd(_aItem,{"PRODUTO"      ,"C",015,0})
Aadd(_aItem,{"ITEM"         ,"C",004,0})
Aadd(_aItem,{"DESC"         ,"C",050,0})
Aadd(_aItem,{"UM"           ,"C",002,0})
Aadd(_aItem,{"LOTE"         ,"C",011,0})
Aadd(_aItem,{"FABRI"        ,"D",008,0})
Aadd(_aItem,{"DTVALID"      ,"D",008,0})
Aadd(_aItem,{"QUANT"        ,"N",014,2})

_cArqItm := CriaTrab(_aItem,.T.)

If Select("ITEM") > 0
	dbCloseArea("ITEM")
EndIF
dbUseArea( .T.,,_cArqItm, "ITEM", .F., .F. )

// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³ Cria arquivo temporario com detalhes do certificado por item (RESUL) ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Aadd(_aResul,{"NOTA"         ,"C",009,0})
Aadd(_aResul,{"SERIE"        ,"C",003,0})
Aadd(_aResul,{"PRODUTO"      ,"C",015,0})
Aadd(_aResul,{"ITEM"         ,"C",004,0})
Aadd(_aResul,{"LOTE"         ,"C",011,0})
Aadd(_aResul,{"ENSAIO"       ,"C",050,0})
Aadd(_aResul,{"NOME"         ,"C",050,0})
Aadd(_aResul,{"ESPEC"        ,"C",050,0})
Aadd(_aResul,{"RESULT"       ,"C",050,0})

_cArqRes := CriaTrab(_aResul,.T.)

If Select("RESUL") > 0
	dbCloseArea("RESUL")
EndIF

dbUseArea(.T.,,_cArqRes,"RESUL",.F.,.F.)

//ProcRegua(VAL(MV_PAR02) - VAL(MV_PAR02))
ProcRegua(VAL(MV_PAR02) - VAL(MV_PAR01))

IF PERGUNTE(cPerg)
	PERGUNTE(cPerg,.F.)
	
	CursorWait()
	
	// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	// ³ Varre Notas Fiscais de Saida com o Filtro Selecionado  ³
	// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DbSelectArea("SF2")
	SF2->(DbSetOrder(1))
	//	IF DBSEEK( XFILIAL("SF2") + MV_PAR01 + MV_PAR03 )
	DBSEEK( XFILIAL("SF2") + MV_PAR01 + MV_PAR03 )
	
	While SF2->(!EOF()) .AND. AllTrim(SF2->F2_FILIAL) == xFilial("SF2") .AND. AllTrim(SF2->F2_DOC) <= AllTrim(MV_PAR02) .AND. AllTrim(SF2->F2_SERIE) <= AllTrim(MV_PAR03)	
		If AllTrim(SF2->F2_SERIE) <> AllTrim(MV_PAR03)
		   SF2->(DBSKIP())
		   LOOP
		ENDIF
		   	
		// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		// ³ So trata Cliente / Desconsidera Fornecedor             ³
		// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SF2->F2_TIPO $ "BD"
			DBSELECTAREA("SF2")
			SF2->(DbSkip())
			Loop
		Endif
		
		cOP := ""
		INCPROC("Selecionando Registros")
		DBSELECTAREA("SA1")
		DBSETORDER(1)
		If SA1->(DBSEEK( xFilial("SA1") + SF2->F2_CLIENTE + SF2->F2_LOJA ))
			// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			// ³ Valida se cliente necessita de certificado             ³
			// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SA1->A1_CERTQUA $ "1/S"
				DBSELECTAREA("SD2")
				DBSETORDER(3)
				
				// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				// ³ Varre os itens da Nota Fiscal                          ³
				// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				IF DBSEEK( XFILIAL("SD2") + SF2->F2_DOC + SF2->F2_SERIE)
					WHILE !EOF() .AND. ALLTRIM(SD2->D2_DOC) == ALLTRIM(SF2->F2_DOC) .AND. ALLTRIM(SD2->D2_SERIE) == ALLTRIM(SF2->F2_SERIE)
						
						// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						// ³ Desconsiderar itens que estiverem fora do range selecionado³
						// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						//If SD2->D2_ITEM < mv_par04 .Or. SD2->D2_ITEM > mv_par05
						If !Empty(AllTrim(mv_par04)) .And. !SD2->D2_COD == mv_par04
							SD2->(DbSkip())
							Loop
						Endif
											
						// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						// ³ Desconsiderar vendas sem numero de lote                ³
						// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If Empty(SD2->D2_LOTECTL)
							SD2->(DbSkip())
							Loop
						Endif
						
						cOP		:= ""
						cProduto := ""
						
						// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						// ³ Analise de quais dados serao impressos no certificado  ³
						// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						
						// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						// ³ 1. Verifica se existe Especificacao, OP e Resultado Deste Lote   ³
						// ³ no Modulo de Inspecao de Processos                               ³
						// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						
						DbSelectArea("QP6")
						QP6->(DbSetOrder(1))
						If QP6->(DbSeek( xFilial("QP6") + SD2->D2_COD)) .AND. QP6->QP6_SKPLOT <> '27'
							cProduto := ALLTRIM(SD2->D2_COD)
							
							DbSelectArea("SC2")
							SC2->(DbSetOrder(10))		// C2_FILIAL+C2_LOTECTL+C2_PRODUTO
							//IF DBSEEK( "01" + SD2->D2_LOTECTL + cProduto) // Daniel Neves - 19.09.05 - Indice sem produto
							If SC2->(DbSeek(xFilial("SC2")+SD2->D2_LOTECTL))
								While SC2->(!EOF()) .AND. SC2->C2_LOTECTL == SD2->D2_LOTECTL  									
									IF AllTrim(SC2->C2_PRODUTO ) == cProduto
										//cOP := SC2->C2_NUM + SC2->C2_ITEM + SC2->C2_SEQUEN
										cOP := AllTrim(SC2->C2_NUM) + AllTrim(SC2->C2_ITEM) + AllTrim(SC2->C2_SEQUEN) //- Daniel N. - os registros tem que ser identicos
										Exit
									ENDIF
									SC2->(DbSkip())
								ENDDO
								
								DbSelectArea("QPR")//Medições – Dados Genéricos
								QPR->(DbSetOrder(8)) 	// QPR_FILIAL+QPR_OP+QPR_LOTE+QPR_OPERAC+QPR_LABOR+QPR_ENSAIO+DTOS(QPR_DTMEDI)+QPR_HRMEDI+STR(QPR_AMOSTR,1)
								If QPR->(DbSeek( xFilial("QPR") + cOP + "  " + SD2->D2_LOTECTL ))
									If GravaCBC("QIP")
										GravaQIP(cOP,SD2->D2_LOTECTL)
									Endif
								Else
									Aadd(aIncon,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto,cOP,"OP " + cOP + " do Lote " + SD2->D2_LOTECTL + " sem resultados"})
									// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									// ³ Inicia analise do proximo item da Nota Fiscal de Saida ³
									// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									DbSelectArea("SD2")
									SD2->(DbSkip())
									Loop
								Endif
								
								// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								// ³ Inicia analise do proximo item da Nota Fiscal de Saida ³
								// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								DbSelectArea("SD2")
								SD2->(DbSkip())
								Loop
								
								// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								// ³ Bloco abaixo comentado em 28/04 - Pois encontramos um produto no QIP e QIE ³
								// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								/*
								Else
								
								Aadd(aIncon,{SD2->D2_DOC + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto," ","Lote " + SD2->D2_LOTECTL + " do produto " + cProduto + " sem OP"})
								// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								// ³ Inicia analise do proximo item da Nota Fiscal de Saida ³
								// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								DbSelectArea("SD2")
								SD2->(DbSkip())
								Loop
								*/
							Endif
						Endif
						
						// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						// ³ 3. Analisa estrutura do produto e imprime valores dos resultados de   ³
						// ³ todos os PIs da estrutura                                             ³
						// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						DbSelectArea("SG1")
						SG1->(DbSetOrder(1))
						QP6->(DbSetOrder(1))
						
						aInconSub1 	:= {}
						aInconSub2 	:= {}
						aEstrutura	:= {}
						
						If SG1->(DbSeek(xFilial("SG1") + SD2->D2_COD))
							lGravaCBC := .f.
							While SG1->(!EOF()) .AND. ;
								AllTrim(SG1->G1_COD) == AllTrim(SD2->D2_COD)
								
								// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								// ³ Considerar somente PI/PAs				                  ³
								// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If ! AllTrim(Posicione("SB1",1,xFilial("SB1")+SG1->G1_COD,"B1_TIPO")) $ "3/4"
									SG1->(DbSkip())
									Loop
								Endif
								
								// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								// ³ Carrega com a estrutura a ser avaliada no nivel 2      ³
								// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								Aadd(aEstrutura,SG1->G1_COMP)
								If QP6->(DbSeek(xFilial("QP6") + SG1->G1_COMP))
									cProduto := ALLTRIM(SG1->G1_COMP)
									
									// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									// ³ O Lote do PA eh igual ao Lote do PI                    ³
									// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									DbSelectArea("SC2")
									SC2->(DbSetOrder(10))		// C2_FILIAL+C2_LOTECTL+C2_PRODUTO
									lNumeroPAPI := .T.
									cOp := ""
									If SC2->(DbSeek(xFilial("SC2") + SD2->D2_LOTECTL))
										While SC2->(!EOF()) .AND. ;
											SC2->C2_LOTECTL == SD2->D2_LOTECTL
											IF AllTrim(SC2->C2_PRODUTO ) == cProduto
												cOP := AllTrim(SC2->C2_NUM) + AllTrim(SC2->C2_ITEM) + AllTrim(SC2->C2_SEQUEN) //- Daniel N. - os registros tem que ser identicos
												Exit
											Endif
											SC2->(DbSkip())
										Enddo		
										If Empty(cOP)
											lNumeroPAPI := .f.
										Else
										//	Aadd(aInconSub1,{SD2->D2_DOC + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto," ","Lote " + SD2->D2_LOTECTL + " sem OP para o produto " + cProduto + " da estrutura"})
										//	SG1->(DbSkip())
										//	Loop

											DbSelectArea("QPR")
											QPR->(DbSetOrder(8)) 	// QPR_FILIAL+QPR_OP+QPR_LOTE+QPR_OPERAC+QPR_LABOR+QPR_ENSAIO+DTOS(QPR_DTMEDI)+QPR_HRMEDI+STR(QPR_AMOSTR,1)
											If QPR->(DbSeek( xFilial("QPR") + cOP + "  " + SD2->D2_LOTECTL ))
												GravaQIP(cOP,SD2->D2_LOTECTL)
												lGravaCBC := .t.
											Else
												Aadd(aInconSub1,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto,cOP,"OP " + cOP + " do Lote " + SD2->D2_LOTECTL + " sem resultados"})
												
												// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
												// ³ Inicia analise do proximo item da estrutura            ³
												// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
												SG1->(DbSkip())
												Loop
											Endif	
										Endif	
									Endif
									
									// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									// ³ Nao encontrou OP de PI com o mesmo numero da OP do PA  ³
									// ³ Ira analisar os lotes utilizados na OP para localizar  ³
									// ³ qual lote de PI foi utilizado na fabricacao do PA e    ³
									// ³ imprime os dados deste lote.                           ³
									// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									If ! lNumeroPaPi
										SC2->(DbSetOrder(10))		// C2_FILIAL+C2_LOTECTL+C2_PRODUTO
										If SC2->(DbSeek(xFilial("SC2") + SD2->D2_LOTECTL + SD2->D2_COD))
											SD3->(DbSetOrder(1))		//	D3_FILIAL+D3_OP+D3_COD+D3_LOCAL
											If SD3->(DbSeek(xFilial("SD3") + SC2->(C2_NUM + C2_ITEM + C2_SEQUEN + C2_ITEMGRD) + cProduto))
												If ! Empty(SD3->D3_LOTECTL)
													If SC2->(DbSeek(xFilial("SC2") + SD3->D3_LOTECTL + cProduto))
														cOp := SC2->(C2_NUM + C2_ITEM + C2_SEQUEN)
														DbSelectArea("QPR")
														QPR->(DbSetOrder(8)) 	// QPR_FILIAL+QPR_OP+QPR_LOTE+QPR_OPERAC+QPR_LABOR+QPR_ENSAIO+DTOS(QPR_DTMEDI)+QPR_HRMEDI+STR(QPR_AMOSTR,1)
														If QPR->(DbSeek( xFilial("QPR") + cOp + "  " + SD3->D3_LOTECTL ))
															GravaQIP(cOP,SD3->D3_LOTECTL)
															lGravaCBC := .t.
														Else
															Aadd(aInconSub1,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD3->D3_LOTECTL,cProduto,cOP,"OP " + cOP + " do Lote " + SD3->D3_LOTECTL + " sem resultados"})
														Endif
													Else
														Aadd(aInconSub1,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD3->D3_LOTECTL,cProduto,cOP,"OP " + cOP + " empenhada nao foi localizada"})
													Endif
												Else
													lSD5 := .f.
													aInconSubX := {}
													
													SD5->(DbSetOrder(4))		//	D5_FILIAL+D5_OP+D5_NUMSEQ
													IF SD5->(DbSeek(xFilial("SD5") + SD3->D3_OP + SD3->D3_NUMSEQ))
														While xFilial("SD5") + SD3->D3_OP + SD3->D3_NUMSEQ ==;
															SD5->D5_FILIAL + SD5->D5_OP + SD5->D5_NUMSEQ .and. ;
															! SD5->(Eof())
															If SD5->D5_PRODUTO <> cProduto
																SD5->(DbSkip())
																Loop
															Endif
															
															// Indice 9 da base estah sem o campo Produto, logo Seek Falha
															// Realizado tratamento abaixo para contornar
															lSC2 := .f.
															If SC2->(DbSeek(xFilial("SC2") + SD5->D5_LOTECTL + cProduto))
																While ! SC2->(Eof()) .and. xFilial("SC2")+ SD5->D5_LOTECTL == SC2->C2_FILIAL + SC2->C2_LOTECTL
																	If AllTrim(cProduto) <> AllTrim(SC2->C2_PRODUTO)
																		SC2->(DbSkip())
																		Loop
																	Endif
																	lSC2 := .t.
																	Exit
																Enddo
															Endif
															If lSC2
																cOp := SC2->(C2_NUM + C2_ITEM + C2_SEQUEN)
																DbSelectArea("QPR")
																QPR->(DbSetOrder(8)) 	// QPR_FILIAL+QPR_OP+QPR_LOTE+QPR_OPERAC+QPR_LABOR+QPR_ENSAIO+DTOS(QPR_DTMEDI)+QPR_HRMEDI+STR(QPR_AMOSTR,1)
																If QPR->(DbSeek( xFilial("QPR") + cOp + "  " + SD5->D5_LOTECTL ))
																	GravaQIP(cOP,SD5->D5_LOTECTL)
																	lGravaCBC	:= .t.
																	lSD5			:= .t.
																	Exit
																Else
																	Aadd(aInconSubX,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD5->D5_LOTECTL,cProduto,cOP,"OP " + cOP + " do Lote " + SD5->D5_LOTECTL + " sem resultados (SD5)"})
																Endif
															Else
																Aadd(aInconSubX,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD5->D5_LOTECTL,cProduto,cOP,"OP " + cOP + " empenhada nao foi localizada"})
															Endif
															SD5->(DbSkip())		
														Enddo
														
														// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
														// ³ Se nao validou nenhum SD5, gera inconsistencias        ³
														// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
														If ! lSD5
															If !Empty(aInconSubX)
																For nConta := 1 To Len(aInconSubX)
																	Aadd(aInconSub1,{aInconSubX[nConta,1],aInconSubX[nConta,2],aInconSubX[nConta,3],aInconSubX[nConta,4],aInconSubX[nConta,5]})
																Next nConta
															Endif
														Endif
													Else
														Aadd(aInconSub1,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM," ",cProduto," ","Empenho foi realizado com lote em branco (SD3/SD5)"})
													Endif
												Endif
											Else
												Aadd(aInconSub1,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM," ",cProduto," ","Empenho nao localizado"})
											Endif
										Else
											Aadd(aInconSub1,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM," ",cProduto," ","Ordem de Producao nao localizada"})
										Endif
									Endif
								Endif
								
								DbSelectArea("SG1")
								SG1->(DbSkip())
							EndDo							
							If lGravaCBC
								// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								// ³ Gravo um cabecalho para o item, pois conseguiu localizar resultados ³
								// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								GravaCBC("QIP")
								
								// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								// ³ Inicia analise do proximo item da Nota Fiscal de Saida ³
								// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								DbSelectArea("SD2")
								SD2->(DbSkip())
								Loop
							Else
								lGravaCBC2 := .f.
								
								// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								// ³ Nao localizou resultados para primeiro nivel, analisa o segundo nivel da estrutura ³
								// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								For nConta := 1 To Len(aEstrutura)
									If SG1->(DbSeek( xFilial("SG1") + aEstrutura[nConta]))
										While SG1->(!EOF()) .AND. ;
											AllTrim(SG1->G1_COD) == AllTrim(aEstrutura[nConta])
											If QP6->(DbSeek(xFilial("QP6") + SG1->G1_COMP))
												cProduto := ALLTRIM(SG1->G1_COMP)
												lNumeroPAPI := .T.
												cOp := ""
												
												// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
												// ³ O Lote do PA eh igual ao Lote do PI                    ³
												// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
												DbSelectArea("SC2")
												SC2->(DbSetOrder(10))		// C2_FILIAL+C2_LOTECTL+C2_PRODUTO
												If SC2->(DbSeek( xFilial("SC2") + SD2->D2_LOTECTL))
													While SC2->(!EOF()) .AND. ;
														SC2->C2_LOTECTL == SD2->D2_LOTECTL
														IF AllTrim(SC2->C2_PRODUTO ) == cProduto
															cOP := AllTrim(SC2->C2_NUM) + AllTrim(SC2->C2_ITEM) + AllTrim(SC2->C2_SEQUEN)
															Exit
														Endif
														SC2->(DbSkip())
													Enddo
													If Empty(cOP)
														lNumeroPAPI := .f.
														
														//															Aadd(aInconSub2,{SD2->D2_DOC + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto," ","Lote " + SD2->D2_LOTECTL + " sem OP para o produto " + cProduto + " da estrutura (nivel 2)"})
														//				              							SG1->(DbSkip())
														//				              							Loop
														//															Endif
													Else
														DbSelectArea("QPR")
														QPR->(DbSetOrder(8)) 	// QPR_FILIAL+QPR_OP+QPR_LOTE+QPR_OPERAC+QPR_LABOR+QPR_ENSAIO+DTOS(QPR_DTMEDI)+QPR_HRMEDI+STR(QPR_AMOSTR,1)
														If QPR->(DbSeek( xFilial("QPR") + cOP + "  " + SD2->D2_LOTECTL ))
															GravaQIP(cOP,SD2->D2_LOTECTL)
															lGravaCBC2 := .t.
														Else
															Aadd(aInconSub2,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto,cOP,"OP " + cOP + " do Lote " + SD2->D2_LOTECTL + " sem resultados (nivel 2)"})
															
															// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
															// ³ Inicia analise do proximo item da estrutura            ³
															// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
															SG1->(DbSkip())
															Loop
														Endif
													Endif
												Endif
												
												// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
												// ³ Nao encontrou OP de PI com o mesmo numero da OP do PA  ³
												// ³ Ira analisar os lotes utilizados na OP para localizar  ³
												// ³ qual lote de PI foi utilizado na fabricacao do PA e    ³
												// ³ imprime os dados deste lote.                           ³
												// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
												If ! lNumeroPaPi
													SC2->(DbSetOrder(10))		// C2_FILIAL+C2_LOTECTL+C2_PRODUTO
													If SC2->(DbSeek(xFilial("SC2") + SD2->D2_LOTECTL + SD2->D2_COD))
														SD3->(DbSetOrder(1))		//	D3_FILIAL+D3_OP+D3_COD+D3_LOCAL
														If SD3->(DbSeek(xFilial("SD3") + SC2->(C2_NUM + C2_ITEM + C2_SEQUEN + C2_ITEMGRD) + cProduto))
															If ! Empty(SD3->D3_LOTECTL)
																If SC2->(DbSeek(xFilial("SC2")+ SD3->D3_LOTECTL + cProduto))
																	cOp := SC2->(C2_NUM + C2_ITEM + C2_SEQUEN)
																	DbSelectArea("QPR")
																	QPR->(DbSetOrder(8)) 	// QPR_FILIAL+QPR_OP+QPR_LOTE+QPR_OPERAC+QPR_LABOR+QPR_ENSAIO+DTOS(QPR_DTMEDI)+QPR_HRMEDI+STR(QPR_AMOSTR,1)
																	If QPR->(DbSeek( xFilial("QPR") + cOp + "  " + SD3->D3_LOTECTL ))
																		GravaQIP(cOP,SD3->D3_LOTECTL)
																		lGravaCBC := .t.
																	Else
																		Aadd(aInconSub1,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD3->D3_LOTECTL,cProduto,cOP,"OP " + cOP + " do Lote " + SD3->D3_LOTECTL + " sem resultados"})
																	Endif
																Else
																	Aadd(aInconSub1,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD3->D3_LOTECTL,cProduto,cOP,"OP " + cOP + " empenhada nao foi localizada"})
																Endif
															Else
																SD5->(DbSetOrder(4))		//	D5_FILIAL+D5_OP+D5_NUMSEQ
																IF SD5->(DbSeek(xFilial("SD5") + SD3->D3_OP + SD3->D3_NUMSEQ))
																	lSD5 := .f.
																	aInconSubX := {}
																	While xFilial("SD5") + SD3->D3_OP + SD3->D3_NUMSEQ ==;
																		SD5->D5_FILIAL + SD5->D5_OP + SD5->D5_NUMSEQ .and. ;
																		! SD5->(Eof())
																		If SD5->D5_PRODUTO <> cProduto
																			SD5->(DbSkip())
																			Loop
																		Endif
																		
																		// Indice 9 da base estah sem o campo Produto, logo Seek Falha
																		// Realizado tratamento abaixo para contornar
																		lSC2 := .f.
																		If SC2->(DbSeek(xFilial("SC2") + SD5->D5_LOTECTL + cProduto))
																			While ! SC2->(Eof()) .and. ;
																				xFilial("SC2") + SD5->D5_LOTECTL == ;
																				SC2->C2_FILIAL + SC2->C2_LOTECTL
																				If AllTrim(cProduto) <> AllTrim(SC2->C2_PRODUTO)
																					SC2->(DbSkip())
																					Loop
																				Endif
																				lSC2 := .t.
																				Exit
																			Enddo
																		Endif
																		If lSC2
																			cOp := SC2->(C2_NUM + C2_ITEM + C2_SEQUEN)
																			DbSelectArea("QPR")
																			QPR->(DbSetOrder(8)) 	// QPR_FILIAL+QPR_OP+QPR_LOTE+QPR_OPERAC+QPR_LABOR+QPR_ENSAIO+DTOS(QPR_DTMEDI)+QPR_HRMEDI+STR(QPR_AMOSTR,1)
																			If QPR->(DbSeek( xFilial("QPR") + cOp + "  " + SD5->D5_LOTECTL ))
																				GravaQIP(cOP,SD5->D5_LOTECTL)
																				lGravaCBC := .t.
																				lSD5 := .t.
																				Exit
																			Else
																				Aadd(aInconSubX,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD5->D5_LOTECTL,cProduto,cOP,"OP " + cOP + " do Lote " + SD5->D5_LOTECTL + " sem resultados (SD5)"})
																			Endif
																		Else
																			Aadd(aInconSubX,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD5->D5_LOTECTL,cProduto,cOP,"OP " + cOP + " empenhada nao foi localizada"})
																		Endif
																		SD5->(DbSkip())
																	Enddo
																	
																	// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
																	// ³ Se nao validou nenhum SD5, gera inconsistencias        ³
																	// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
																	If ! lSD5
																		If !Empty(aInconSubX)
																			For nConta := 1 To Len(aInconSubX)
																				Aadd(aInconSub1,{aInconSubX[nConta,1],aInconSubX[nConta,2],aInconSubX[nConta,3],aInconSubX[nConta,4],aInconSubX[nConta,5]})
																			Next nConta
																		Endif
																	Endif
																Else
																	Aadd(aInconSub1,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM," ",cProduto," ","Empenho foi realizado com lote em branco (SD3/SD5)"})
																Endif
															Endif
														Else
															Aadd(aInconSub1,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM," ",cProduto," ","Empenho nao localizado"})
														Endif
													Else
														Aadd(aInconSub1,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM," ",cProduto," ","Ordem de Producao nao localizada"})
													Endif
												Endif
											Endif
											
											DbSelectArea("SG1")
											SG1->(DbSkip())
										EndDo
									Endif	// Localiza Estrutura de Segundo Nivel
								Next nConta
							Endif
							
							// Grava Inconsistencias do nivel 2 ou nivel 1
							If ! lGravaCBC2
								lProximo := .f.
								If ! Empty(aInconSub2)
									lProximo := .t.
									For nConta := 1 To Len(aInconSub2)
										Aadd(aIncon,{aInconSub2[nConta,1],aInconSub2[nConta,2],aInconSub2[nConta,3],aInconSub2[nConta,4],aInconSub2[nConta,5]})
									Next nConta
								Endif
								If ! Empty(aInconSub1)
									lProximo := .t.
									For nConta := 1 To Len(aInconSub1)
										Aadd(aIncon,{aInconSub1[nConta,1],aInconSub1[nConta,2],aInconSub1[nConta,3],aInconSub1[nConta,4],aInconSub1[nConta,5]})
									Next nConta
								Endif
								If lProximo
									// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									// ³ Inicia analise do proximo item da Nota Fiscal de Saida ³
									// ³ Pois ja logou inconsistencia                           ³
									// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									DbSelectArea("SD2")
									SD2->(DbSkip())
									Loop
								Endif
							Else								
								// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								// ³ Gravo um cabecalho para o item, pois conseguiu localizar resultados ³
								// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								GravaCBC("QIP")
								// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								// ³ Inicia analise do proximo item da Nota Fiscal de Saida ³
								// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								DbSelectArea("SD2")
								SD2->(DbSkip())
								Loop
							Endif
						Endif						
						
						// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						// ³ 2. Verifica se existe Especificacao, Entrega e Resultado Deste Lote   ³
						// ³ no Modulo de Inspecao de Entregas                                     ³
						// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						
						DbSelectArea("QE6")
						QE6->(DbSetOrder(1))
						If QE6->(DbSeek( xFilial("QE6") + SD2->D2_COD))
							cProduto := ALLTRIM(SD2->D2_COD)
							
							DbSelectArea("QEK")
							QEK->(DbSetOrder(6))		// QEK_FILIAL + QEK_LOTE
							// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							// ³ Tera que localizar uma entrada deste lote, desconsiderando os ³
							// ³ sub-lotes do mesmo. Pela qualidade, todos os sub-lotes deste  ³
							// ³ lote, possuem os mesmos resultados.                           ³
							// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							
							nCasas 	:= Len(AllTrim(SD2->D2_LOTECTL))
							cLote	:= ""
							If QEK->(DbSeek( xFilial("QEK") + AllTrim(SD2->D2_LOTECTL)))
								While QEK->(!Eof()) .and. ;
									QEK->QEK_FILIAL == xFilial("QEK") .and. ;
									Substr(QEK->QEK_LOTE,1,nCasas) == AllTrim(SD2->D2_LOTECTL)
									//If Len(AllTrim(QEK->QEK_LOTE)) == nCasas + 6 .and. ;	// 6 posicoes de Sub-Lote
									//	QEK->QEK_PRODUT == SD2->D2_COD
									IF alltrim(QEK->QEK_LOTE) == alltrim(SD2->D2_LOTECTL) .AND. QEK->QEK_PRODUT == SD2->D2_COD
										cLote := QEK->QEK_LOTE
										cChave:= QEK->(QEK_PRODUT+QEK_REVI+QEK_FORNEC+QEK_LOJFOR+DTOS(QEK_DTENTR)+QEK_LOTE)
										Exit
									Endif
									QEK->(DbSkip())
								Enddo
							Endif
							If ! Empty(cLote )
								DbSelectArea("QER")
								QER->(DbSetOrder(1)) 	// QER_FILIAL+QER_PRODUT+QER_REVI+QER_FORNEC+QER_LOJFOR+DTOS(QER_DTENTR)+QER_LOTE+QER_LABOR+QER_ENSAIO+DTOS(QER_DTMEDI)+QER_HRMEDI+STR(QER_AMOSTR,1)
								If QER->(DbSeek( xFilial("QER") + cChave ))
									If GravaCBC("QIE")
										GravaQIE(cChave)
									Endif
									// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									// ³ Inicia analise do proximo item da Nota Fiscal de Saida ³
									// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									DbSelectArea("SD2")
									SD2->(DbSkip())
									Loop
								Else
									Aadd(aIncon,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto,cLote,"Entrega do lote " + cLote + " sem resultados"})
									// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									// ³ Inicia analise do proximo item da Nota Fiscal de Saida ³
									// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									DbSelectArea("SD2")
									SD2->(DbSkip())
									Loop
								Endif
							Else
								Aadd(aIncon,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto," ","Entrega não localizada do Lote " + SD2->D2_LOTECTL})
								// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								// ³ Inicia analise do proximo item da Nota Fiscal de Saida ³
								// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								DbSelectArea("SD2")
								SD2->(DbSkip())
								Loop
							Endif
						Else
							//verifica pelo PI 
						    cCodPIAx:= ""
							DbSelectArea("SG1")
							DbSetOrder(1)
							MsSeek(xFilial("SG1")+SD2->D2_COD)
							While !Eof() .And. SG1->G1_COD==SD2->D2_COD
								If AllTrim(Posicione("SB1",1,xFilial("SB1")+SG1->G1_COMP,"B1_TIPO"))=="4"
									cCodPIAx:= SG1->G1_COMP								
								EndIf	
								DbSelectArea("SG1")
								DbSkip()
							EndDo

							DbSelectArea("QE6")
							QE6->(DbSetOrder(1))
							If QE6->(DbSeek( xFilial("QE6") + cCodPIAx))
								cProduto := ALLTRIM(SD2->D2_COD) //cCodPIAx)
								
								DbSelectArea("QEK")
								QEK->(DbSetOrder(6))		// QEK_FILIAL + QEK_LOTE
								// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								// ³ Tera que localizar uma entrada deste lote, desconsiderando os ³
								// ³ sub-lotes do mesmo. Pela qualidade, todos os sub-lotes deste  ³
								// ³ lote, possuem os mesmos resultados.                           ³
								// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								nCasas 	:= Len(AllTrim(SD2->D2_LOTECTL))
								cLote	:= ""
								If QEK->(DbSeek( xFilial("QEK") + AllTrim(SD2->D2_LOTECTL)))
									While QEK->(!Eof()) .and. ;
										QEK->QEK_FILIAL == xFilial("QEK") .and. ;
										Substr(QEK->QEK_LOTE,1,nCasas) == AllTrim(SD2->D2_LOTECTL)
										If Len(AllTrim(QEK->QEK_LOTE)) == nCasas + 6 .and. ;	// 6 posicoes de Sub-Lote
											QEK->QEK_PRODUT == SD2->D2_COD
											cLote := QEK->QEK_LOTE
											cChave := QEK->(QEK_PRODUT+QEK_REVI+QEK_FORNEC+QEK_LOJFOR+DTOS(QEK_DTENTR)+QEK_LOTE)
											Exit
										Endif
										QEK->(DbSkip())
									Enddo
								Endif
								If ! Empty(cLote )
									DbSelectArea("QER")
									QER->(DbSetOrder(1)) 	// QER_FILIAL+QER_PRODUT+QER_REVI+QER_FORNEC+QER_LOJFOR+DTOS(QER_DTENTR)+QER_LOTE+QER_LABOR+QER_ENSAIO+DTOS(QER_DTMEDI)+QER_HRMEDI+STR(QER_AMOSTR,1)
									If QER->(DbSeek( xFilial("QER") + cChave ))
										If GravaCBC("QIE")
											GravaQIE(cChave)
										Endif
										// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
										// ³ Inicia analise do proximo item da Nota Fiscal de Saida ³
										// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
										DbSelectArea("SD2")
										SD2->(DbSkip())
										Loop
									Else
										Aadd(aIncon,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto,cLote,"Entrega do lote " + cLote + " sem resultados"})
										// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
										// ³ Inicia analise do proximo item da Nota Fiscal de Saida ³
										// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
										DbSelectArea("SD2")
										SD2->(DbSkip())
										Loop
									Endif
								Else
									Aadd(aIncon,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto," ","Entrega não localizada do Lote " + SD2->D2_LOTECTL})
									// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									// ³ Inicia analise do proximo item da Nota Fiscal de Saida ³
									// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									DbSelectArea("SD2")
									SD2->(DbSkip())
									Loop
								Endif
							EndIf
						Endif
						
						// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						// ³ Gerar Inconsistencia, pois nao atendeu nenhuma regra acima ³
						// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						Aadd(aIncon,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,SD2->D2_COD," ","Lote não atendeu nenhuma regra"})
						// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						// ³ Inicia analise do proximo item da Nota Fiscal de Saida ³
						// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						DbSelectArea("SD2")
						SD2->(DbSkip())
					ENDDO
				ENDIF
			ENDIF
		ELSE
			MSGBOX("CLIENTE NAO ENCONTRADO")
			DBSELECTAREA("SF2")
			SF2->(DbSkip())
		ENDIF		
		// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		// ³ Inicia analise da proxima Nota Fiscal de Saida ³
		// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DBSELECTAREA("SF2")
		DBSKIP()
	ENDDO
	//	ELSE     dan
	//	MSGBOX("NOTA FISCAL INICIAL NAO ENCONTRADA")  dan
	//	ENDIF          dan
	
	CursorArrow()
	
	// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	// ³ Chama rotina de impressao das inconsistencias e envia as mesmas por e-mail ³
	// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ! Empty(aIncon)
		U_LogIncon()
		EnviaIncon()
	Endif
	
	// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	// ³ Chama rotina de impressao dos certificados  ³
	// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	U_IMPRCERT()
Endif

CBC->(DBCLOSEAREA())
FERASE(_cArqCbc)
ITEM->(DBCLOSEAREA())
FERASE(_cArqItm)
RESUL->(DBCLOSEAREA())
FERASE(_cArqRes)

RETURN(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GravaQIP  ºAutor  ³Rogerio Nagy        º Data ³  02/06/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Grava dados do certificado de um determinado Lote, Produto º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function GravaQIP(cOp,cLote)

// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³ Guarda valores temporarios do certificado com dados do Inspecao de Processos ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

DBSELECTAREA("QPR")
QPR->(DbSetOrder(8)) 	// QPR_FILIAL+QPR_OP+QPR_LOTE+QPR_OPERAC+QPR_LABOR+QPR_ENSAIO+DTOS(QPR_DTMEDI)+QPR_HRMEDI+STR(QPR_AMOSTR,1)
If QPR->(DbSeek( xFilial("QPR") + cOP + "  " + cLote ))
	//IF ALLTRIM(cOP) == ALLTRIM(QPR->QPR_OP) // INCLUIDO APOS ALTERACAO DE IF DBSEEK
	WHILE !EOF() .AND. ALLTRIM(QPR->QPR_OP) == ALLTRIM(cOP) .and. ;
		Substr(QPR->QPR_LOTE,1,10) == cLote
		
		DBSELECTAREA("RESUL")
		RECLOCK("RESUL",.T.)
		RESUL->NOTA   := ALLTRIM(SF2->F2_DOC)
		RESUL->SERIE  := ALLTRIM(SF2->F2_SERIE)
		RESUL->PRODUTO:= ALLTRIM(SD2->D2_COD)
		RESUL->ITEM   := SD2->D2_ITEM
		RESUL->LOTE   := ALLTRIM(SD2->D2_LOTECTL)
		RESUL->ENSAIO := ALLTRIM(QPR->QPR_ENSAIO)
		cChave        := ALLTRIM(QPR->QPR_CHAVE)
		
		DBSELECTAREA("QP1")
		DBSETORDER(1)
		IF DBSEEK( XFILIAL("QP1") + QPR->QPR_ENSAIO )
			RESUL->NOME := QP1->QP1_DESCPO
		ENDIF
		
		DBSELECTAREA("QP8")
		DBSETORDER(3)
		IF DBSEEK( XFILIAL("QP8") + QPR->QPR_ENSAIO + cProduto )
			Do while !EOF() .AND. QPR->QPR_ENSAIO == QP8->QP8_ENSAIO .AND. ALLTRIM(cProduto) == ALLTRIM (QP8->QP8_PRODUT)
				IF QPR->QPR_REVI == QP8->QP8_REVI
					RESUL->ESPEC := ALLTRIM(QP8->QP8_TEXTO)
					DBSKIP()
				ELSE
					DBSKIP()
				ENDIF
			ENDDO
			
			DBSELECTAREA("QPQ")
			DBSETORDER(1)
			IF DBSEEK( XFILIAL("QPS") + cChave )
				RESUL->RESULT  := ALLTRIM(QPQ->QPQ_MEDICA)
			ENDIF
			MSUNLOCK()
		ELSE
			DBSELECTAREA("QP7")
			DBSETORDER(3)
			QP7->(DBGOTOP())
			IF DBSEEK( XFILIAL("QP7") + QPR->QPR_ENSAIO + cProduto)
				Do while !EOF() .AND. QPR->QPR_ENSAIO == QP7->QP7_ENSAIO .AND. ALLTRIM(cProduto) == ALLTRIM (QP7->QP7_PRODUT)
					IF QPR->QPR_REVI == QP7->QP7_REVI
						RESUL->ESPEC := ALLTRIM(QP7->QP7_LIE)+ " / " + ALLTRIM(QP7->QP7_LSE)
						DBSKIP()
					ELSE
						DBSKIP()
					ENDIF
				ENDDO
				DBSELECTAREA("QPS")
				DBSETORDER(1)
				IF DBSEEK( XFILIAL("QPS") + cChave ) //1
					RESUL->RESULT := QPS->QPS_MEDICA
					MSUNLOCK()
				ENDIF //1
			ENDIF
		ENDIF
		DBSELECTAREA("QPR")
		DBSKIP()
	ENDDO
ELSE
	MSGBOX("OP "+cOP+" DO PRODUTO:"+ cProduto +", NAO ENCONTRADA NOS RESULTADOS, POR FAVOR, CRIAR O MESMO MANUALMENTE") //Alterado apos acerto de QPR
ENDIF

Return .t.


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GravaQIE  ºAutor  ³Rogerio Nagy        º Data ³  02/06/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Grava dados do certificado de um determinado lote.          º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function GravaQIE(cChave)

Local cChaveQE := ""

// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³ Guarda valores temporarios do certificado com dados do Inspecao de Entregas  ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

DbSelectArea("QER")
QER->(DbSetOrder(1))
If QER->(DbSeek( xFilial("QER") + cChave ))
	While QER->(!EOF()) .AND. ;
		cChave == QER->(QER_PRODUT+QER_REVI+QER_FORNEC+QER_LOJFOR+DTOS(QER_DTENTR)+QER_LOTE)
		
		DbSelectArea("RESUL")
		RecLock("RESUL",.T.)
		RESUL->NOTA   := AllTrim(SF2->F2_DOC)
		RESUL->SERIE  := AllTrim(SF2->F2_SERIE)
		RESUL->PRODUTO:= AllTrim(SD2->D2_COD)
		RESUL->ITEM   := SD2->D2_ITEM
		RESUL->LOTE   := AllTrim(SD2->D2_LOTECTL)
		RESUL->ENSAIO := AllTrim(QER->QER_ENSAIO)
		cChaveQE      := AllTrim(QER->QER_CHAVE)
		
		DbSelectArea("QE1")
		QE1->(DbSetOrder(1))
		If QE1->(DbSeek( xFilial("QE1") + QER->QER_ENSAIO ))
			RESUL->NOME := QE1->QE1_DESCPO
		Endif
		
		DbSelectArea("QE8")
		QE8->(DbSetOrder(3))  // QE8_FILIAL+QE8_ENSAIO+QE8_PRODUT+QE8_REVI
		If QE8->(DbSeek( xFilial("QE8") + QER->QER_ENSAIO + cProduto ))
			While QE8->(!EOF()) .AND. ;
				QER->QER_ENSAIO == QE8->QE8_ENSAIO .AND. ;
				AllTrim(cProduto) == AllTrim (QE8->QE8_PRODUT)
				If QER->QER_REVI == QE8->QE8_REVI
					RESUL->ESPEC := AllTrim(QE8->QE8_TEXTO)
				Endif
				QE8->(DBSkip())
			Enddo
			
			DbSelectArea("QEQ")
			QEQ->(DbSetOrder(1))
			If QEQ->(DbSeek( xFilial("QEQ") + cChaveQE ))
				RESUL->RESULT  := ALLTRIM(QEQ->QEQ_MEDICA)
			Endif
			MSUNLOCK()
		Else
			DbSelectArea("QE7")
			QE7->(DbSetOrder(3))  	// QE7_FILIAL+QE7_ENSAIO+QE7_PRODUT+QE7_REVI
			//QE7->(DBGOTOP())
			If QE7->(DbSeek( xFilial("QE7") + QER->QER_ENSAIO + cProduto))
				While QE7->(!EOF()) .AND. ;
					QER->QER_ENSAIO == QE7->QE7_ENSAIO .AND. ;
					AllTrim(cProduto) == AllTrim (QE7->QE7_PRODUT)
					If QER->QER_REVI == QE7->QE7_REVI
						RESUL->ESPEC := AllTrim(QE7->QE7_LIE)+ " / " + AllTrim(QE7->QE7_LSE)
					Endif
					QE7->(DBSkip())
				Enddo
				
				DbSelectArea("QES")
				QES->(DbSetOrder(1))		//QES_FILIAL+QES_CODMED
				If QES->(DbSeek( xFilial("QES") + cChaveQE ))
					RESUL->RESULT := QES->QES_MEDICA
				Endif
				MSUNLOCK()
			Endif
		Endif
		DbSelectArea("QER")
		QER->(DbSkip())
	Enddo
Endif

Return .t.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GravaCBC  ºAutor  ³Rogerio Nagy        º Data ³  02/06/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Grava Cabecalho e Itens do Certificado                      º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function GravaCBC(cModulo)

Local lRet 	:= .T.
Local dData := Ctod("  /  /  ")

DbSelectArea("SB1")
DbSetOrder(1)
DbSeek( xFilial("SB1") + SD2->D2_COD )
If cModulo == "QIE"
	// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	// ³ Valida se Data de Fabricacao calculada eh maior que a data atual             ³
	// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	
	// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	// ³ Localiza Nota Fiscal de Entrada deste Lote                                   ³
	// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SD1->(DbSetOrder(4))		// D1_FILIAL+D1_NUMSEQ
	If SD1->(DbSeek(xFilial("SD1") + QEK->QEK_NUMSEQ))
		If Empty(SD1->D1_DTVALID)
			Aadd(aIncon,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto,cLote,"Data de validade em branco na NF de entrada"})
			Return .f.
		Endif
		dData	:= SD1->D1_DTVALID - (SB1->B1_MESVALI * 30)
	Endif
	If dData > dDataBase
		Aadd(aIncon,{RTrim(SD2->D2_DOC) + "/" + SD2->D2_ITEM,SD2->D2_LOTECTL,cProduto,cLote,"Data de fabricacao calculada " + Dtoc(dData) +  " superior a data base"})
		Return .f.
	Endif
Endif

DBSELECTAREA("CBC")
RECLOCK("CBC",.T.)
CBC->NOTA     := ALLTRIM(SF2->F2_DOC)
CBC->SERIE    := ALLTRIM(SF2->F2_SERIE)
CBC->CLIENTE  := ALLTRIM(SF2->F2_CLIENTE)
CBC->LOJA     := ALLTRIM(SF2->F2_LOJA)
CBC->NOME     := ALLTRIM(SA1->A1_NOME)
CBC->EMISSAO  := SF2->F2_EMISSAO
CBC->PRODUTO  := ALLTRIM(SD2->D2_COD)
CBC->ITEM     := SD2->D2_ITEM
MSUNLOCK()

DBSELECTAREA("ITEM")
RECLOCK("ITEM",.T.)
ITEM->NOTA     := ALLTRIM(SF2->F2_DOC)
ITEM->SERIE    := ALLTRIM(SF2->F2_SERIE)
ITEM->PRODUTO  := ALLTRIM(SD2->D2_COD)
ITEM->ITEM     := SD2->D2_ITEM
ITEM->DESC  	:= ALLTRIM(SB1->B1_DESC)
ITEM->UM       := ALLTRIM(SD2->D2_UM)
ITEM->QUANT    := SD2->D2_QUANT
ITEM->LOTE     := ALLTRIM(SD2->D2_LOTECTL)
If cModulo == "QIP"
	// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	// ³ Imprime Data de Fabricacao e Validade conforme Ordem de Producao             ³
	// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DBSELECTAREA("SC2")
	DBSETORDER(10)    // C2_FILIAL+C2_LOTECTL+C2_PRODUTO
	IF DBSEEK( xFilial("SC2") + SD2->D2_LOTECTL)
		//ITEM->FABRI := SC2->C2_EMISSAO RODOLFO A PEDIDO DO FABIO PCP FOI TROCADO PELA C2_DATPRINI 27/12
		ITEM->FABRI := SC2->C2_DATPRI
	ENDIF
	
	DBSELECTAREA("SB8")
	DBSETORDER(6)
	IF DBSEEK( XFILIAL("SB8") + SD2->D2_LOTECTL)
		ITEM->DTVALID := SB8->B8_DTVALID
	ENDIF
Else
	// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	// ³ Imprime Data de Validade informada na Nota Fiscal de Entrada                 ³
	// ³ Imprime Data de Fabricacao com Data de Validade Menos Periodo de Validade do ³
	// ³ Produto                                                                      ³
	// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	
	// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	// ³ Localiza Nota Fiscal de Entrada deste Lote                                   ³
	// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SD1->(DbSetOrder(4))		// D1_FILIAL+D1_NUMSEQ
	If SD1->(DbSeek(xFilial("SD1") + QEK->QEK_NUMSEQ))
		ITEM->DTVALID 	:= SD1->D1_DTVALID
		ITEM->FABRI 	:= SD1->D1_DTVALID - (SB1->B1_MESVALI * 30)
	Endif
Endif

MSUNLOCK()

Return .t.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LogInco   º Autor ³ Rogerio Nagy       º Data ³ 06/02/2005  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Imprime Relacao de inconsistencias                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Brascola                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
User Function LogIncon()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Declaracao de Variaveis                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Local   cDesc1     := "Este programa tem como objetivo imprimir relatorio "
Local   cDesc2     := "contendo as inconsistencias de certificados."
Local   cDesc3     := "Certificados Inconsistentes"
Local   cPict      := ""
Local   imprime    := .T.
Private aOrd       := {}
Private nLin       := 80
Private Cabec1     := "NF/Seq        Lote      Produto          OP                Inconsistencia"
Private Cabec2     := ""
Private lEnd       := .F.
Private lAbortPrint:= .F.
Private CbTxt      := ""
Private limite     := 132
Private tamanho    := "M"
Private nTipo      := 15
Private aReturn    := { "Zebrado", 1, "Administracao", 1, 2, 1, "", 1}
Private nLastKey   := 0
Private cbtxt      := Space(10)
Private cbcont     := 00
Private CONTFL     := 01
Private m_pag      := 01
Private wnrel      := "CERTQUA3"
Private cString    := ""
Private nomeprog   := "CERTQUA3"
Private aLinha     := { },nLastKey := 0
Private cPerg      := ""
Private Titulo     := "RELACAO DE CERTIFICADOS INCONSISTENTES"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta a interface padrao com o usuario...                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

//wnrel := SetPrint(cString,NomeProg,"",titulo,cDesc1,cDesc2,cDesc3,.F.,aOrd,.F.,Tamanho,,.F.)
wnrel:= SetPrint(cString,wnrel,"",Titulo,cDesc1,cDesc2,cDesc3,.f.)

If nLastKey == 27
	Return
Endif

SetDefault(aReturn,cString)

If nLastKey == 27
	Return
Endif

nTipo := If(aReturn[4]==1,15,18)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Processamento. RPTSTATUS monta janela com a regua de processamento. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

//RptStatus({|| RunReport(Cabec1,Cabec2,Titulo,nLin,NomeProg,Tamanho,nTipo) },Titulo)

//Processa({ || U_GeraCert(Cabec1,Cabec2,Titulo,nLin,NomeProg,Tamanho,nTipo)}, Titulo,,.t.)
Processa({ || U_GeraCert()}, Titulo,,.t.)

Return  .t.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFun‡„o    ³RUNREPORT º Autor ³ Rogerio Nagy       º Data ³ 06/02/2006  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescri‡„o ³ Funcao auxiliar chamada pela RPTSTATUS. A funcao RPTSTATUS º±±
±±º          ³ monta a janela com a regua de processamento.               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Programa CERT2                                             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
User Function GeraCert() //Cabec1,Cabec2,Titulo,nLin,NomeProg,Tamanho,nTipo)
************************
//Local nOrdem
Local nConta

//SetRegua(Len(aIncon))
ProcRegua(Len(aIncon))

For nConta := 1 To Len(aIncon)	
	//IncRegua()
	IncProc()
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica o cancelamento pelo usuario...                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	
	If lAbortPrint
		@nLin,00 PSAY "*** CANCELADO PELO OPERADOR ***"
		Exit
	Endif
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Impressao do cabecalho do relatorio. . .                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	
	If nLin > 55 // Salto de Página. Neste caso o formulario tem 55 linhas...
		//Cabec(Titulo,Cabec1,/*Cabec2*/" ",NomeProg,/*Tamanho*/1,/*nTipo*/15)
		nLin:= Cabec(Titulo,Cabec1,Cabec2,NomeProg,Tamanho,nTipo,,.F.)
		nLin++
	Endif
	
	@ nLin, 000 PSAY AllTrim(aIncon[nConta,1])
	@ nLin, 013 PSAY aIncon[nConta,2]
	@ nLin, 025 PSAY aIncon[nConta,3]
	@ nLin, 038 PSAY aIncon[nConta,4]
	@ nLin, 056 PSAY aIncon[nConta,5]
	nLin++
	
Next nConta

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Finaliza a execucao do relatorio...                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

SET DEVICE TO SCREEN

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se impressao em disco, chama o gerenciador de impressao...          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If aReturn[5]==1
	dbCommitAll()
	SET PRINTER TO
	OurSpool(wnrel)
Endif
MS_FLUSH()

Return .t.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³EnviaInconºAutor  ³Rogerio Nagy        º Data ³  02/07/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Envia inconsistencias encontradas por e-mail               º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Brascola                                                  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function EnviaIncon

Local _cServer := GetMV("MV_RELSERV")   	// Servidor
Local _cConta  := GetMV("MV_RELACNT")   	// Conta
Local _cPass   := GetMV("MV_RELPSW")   	// Senha da conta
Local _cResp   := GetMv("BR_EMCERTI")		// Responsavel pelas inconsistencias do certificado
Local _cBody	:= " "
Local _cErro 	:= ""
Local lOk 		:= .t.

_cBody    :="<HTML>"
_cBody    += "<HEAD><TITLE> Inconsistências encontradas na emissão de certificados da qualidade</TITLE></HEAD>"
_cBody    += "<BODY>"
_cBody    +="<p style=line-height: 100%; margin-top: 0; margin-bottom: 0></p>"
_cBody    +="<P> </P>"
_cBody    +="<P> </P>"
_cBody    +="<P> </P>"
_cBody    +="<P> Favor verificar inconsistências encontradas abaixo" + "</P>"
_cBody    +="<P> </P>"
_cBody    +="<P> </P>"
_cBody    += "<table bordercolor=#0099cc height=15 cellspacing=1 width=620 bordercolorlight=#0099cc  border=1>"
_cBody    += '<tr><td align=center width=065 height=15><font face="Arial Black" size=1>Nota Fiscal</font></td>'
_cBody    += '    <td align=center width=100 height=15><font face="Arial Black" size=1>Lote</font></td>'
_cBody    += '    <td align=center width=110 height=15><font face="Arial Black" size=1>Produto</font></td>'
_cBody    += '    <td align=center width=90 height=15><font face="Arial Black" size=1>OP</font></td>'
_cBody    += '    <td align=center width=350 height=15><font face="Arial Black" size=1>Inconsistência</font></td>'

For nConta := 1 To Len(aIncon)
	_cBody += '<tr><td align=center width=065 height=15> <font face="Arial" size=1>'+ aIncon[nConta,1]+'</font></td>'
	_cBody += '    <td align=center width=100 height=15> <font face="Arial" size=1>'+ Iif(Empty(aIncon[nConta,2]),"-",aIncon[nConta,2])+'</font></td>'
	_cBody += '    <td align=center width=110 height=15> <font face="Arial" size=1>'+ Iif(Empty(aIncon[nConta,3]),"-",aIncon[nConta,3])+'</font></td>'
	_cBody += '    <td align=center width=090 height=15> <font face="Arial" size=1>'+ Iif(Empty(aIncon[nConta,4]),"-",aIncon[nConta,4])+'</font></td>'
	_cBody += '    <td align=center width=350 height=15> <font face="Arial" size=1>'+ Iif(Empty(aIncon[nConta,5]),"-",aIncon[nConta,5])+'</font></td></tr>'
Next nConta

_cBody    +="</table>"
_cBody    +="<P> </P>"
_cBody    +="<P> </P>"
_cBody    +="<P> </P>"
_cBody    +="<P> E-mail gerado pelo módulo Quality em " + dtoc(ddatabase) + "as " + Left(Time(),5) + "</P>"
_cBody    += "</BODY>"
_cBody    +="</HTML>"+"<P> </P>"+"<P> </P>"+"<P> </P>"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Envia e-mail para aviso de Inconsistencia                        ³
//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
CONNECT SMTP SERVER _cServer ACCOUNT _cConta PASSWORD _cPass RESULT lOk

If lOk
	//Envio de e-mail HTML
	SEND MAIL FROM _cConta ;
	TO _cResp ;
	SUBJECT 'Inconsistência na emissão de Certificados de Qualidade' ;
	BODY _cBody ;
	RESULT lOk
	If !lOk
		//Erro no Envio do e-mail
		GET MAIL ERROR cError
		MsgInfo(cError,OemToAnsi("Erro no envio de e-mail"))
	EndIf
Else
	//Erro na conexao com o SMTP Server
	GET MAIL ERROR cError
	MsgInfo(cError,OemToAnsi("Erro na conexão com o servidor de e-mail"))
EndIf

DISCONNECT SMTP SERVER

Return .T.
